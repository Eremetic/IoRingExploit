#include "LoadLibrary.hpp"
#include "Console.hpp"
#include "HasherLibrary.hpp"
#include "XorStr.hpp"

#include <iostream>
#include <Shlobj.h>






void* LibraryLoader::CustomLoadLibrary(__in const wchar_t* moduleName, __out std::size_t* szImage, __in bool isFilePath, __in int fileFlag, __in int loadFlag)
{
	void* mappedImage = nullptr;
	std::size_t szMappedImage = 0;
	int processCheck = 0;
	if (!this->MapLibrary(moduleName, &mappedImage, isFilePath, &szMappedImage)) return nullptr;

	if (loadFlag == MapDataOnly) 
	{
		*szImage = szMappedImage;
		return mappedImage;
	}


	if (loadFlag == LoadForData && fileFlag == FileIsExe)
	{

		if (!this->ProcessExecutable(mappedImage))
		{
			return nullptr;
		}
		else
		{
			CPrintBland(xorstr_("Success"))
			*szImage = szMappedImage;
			return mappedImage;
		}
	}


	if (loadFlag == LoadWithExecute && fileFlag == FileIsDll)
	{
		processCheck = this->ProcessImage(mappedImage, fileFlag, loadFlag);
		if (processCheck == (false - 1) && loadFlag == LoadWithExecute)
		{
			CPrintWarning(xorstr_("Library Loader"), xorstr_("Library Successfully Loaded, But Failed To Fetch Entry Point"))
		}
		else if (processCheck == (false - 2) && loadFlag == LoadWithExecute)
		{
			CPrintWarning(xorstr_("Library Loader"), xorstr_("Library Successfully Loaded, But Failed To Execute Dll"))
		}
		else if (processCheck == false)
		{
			CPrintError(xorstr_("Library Loader"), xorstr_("Failed To Process Image"))
			return nullptr;
		}
	}

	CPrint(xorstr_("Library Loader"), xorstr_("Success, Loaded Image"))
	*szImage = szMappedImage;
	return mappedImage;
}



bool LibraryLoader::Init()
{
	CPrint(xorstr_("Library Loader"), xorstr_("Library Loader Init"))

	
	this->ntdllHash = HASHSTRW(xorstr_(L"ntdll.dll"));
	this->hashedNames.ntOpenFile = HASHSTRA(xorstr_("NtOpenFile"));
	this->hashedNames.ntOpenFile = HASHSTRA(xorstr_("NtOpenFile"));
	this->hashedNames.ntReadFile = HASHSTRA(xorstr_("NtReadFile"));
	this->hashedNames.ntQueryInformationFile = HASHSTRA(xorstr_("NtQueryInformationFile"));
	this->hashedNames.ntAllocateVirtualMemory = HASHSTRA(xorstr_("NtAllocateVirtualMemory"));
	this->hashedNames.ntFreeVirtualMemory = HASHSTRA(xorstr_("NtFreeVirtualMemory"));
	this->hashedNames.RtlAddFunctionTable = HASHSTRA(xorstr_("RtlAddFunctionTable"));
	this->hashedNames.ntClose = HASHSTRA(xorstr_("NtClose"));
	this->hashedNames.LdrLoadDll = HASHSTRA(xorstr_("LdrLoadDll"));
	this->hashedNames.LdrGetProcedureAddress = HASHSTRA(xorstr_("LdrGetProcedureAddress"));
	
	this->apiString = xorstr_(L"api-");
	this->extString = xorstr_(L"ext-");
	this->SystemFilePath = xorstr_(L"\\??\\");
	
	if (!this->FetchSystemPathUtil())
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Library Loader Initialization Failed Due To Invalid System File Path"))
		return false;
	}
	if (!this->FetchFunctionPtrsUtil())
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Library Loader Initialization Failed Due To Invalid Function pointer"))
		return false;
	}

	CPrint(xorstr_("Library Loader"), xorstr_("Library Loader Initialization Complete"))

	return true;
}


bool LibraryLoader::MapLibrary(__in const wchar_t* moduleName, __out void** mappedModuleBase, __in bool isFilePath, __out std::size_t* szFile)
{
	
	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Attempting To Map New Image..."))
	
	if (!mappedModuleBase || !moduleName)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("MapLibrary; Invalid Parameter"))
		return false;
	}
	


	auto pNtCLose = (fnNtCLose)this->FetchFunction(this->hashedNames.ntClose);

	auto fileStdInfo = std::make_unique<FILE_STANDARD_INFORMATION>();
	auto fileAtts = std::make_unique<OBJECT_ATTRIBUTES>();
	auto ioStatus = std::make_unique<IO_STATUS_BLOCK>();
	auto uniStr = std::make_unique<UNICODE_STRING>();
	NTSTATUS			    status = 1;
	HANDLE			   hFile = nullptr;
	std::wstring ntModuleName; ntModuleName.reserve(MAX_PATH);
	
	
	if (!isFilePath)
	{
		if (!this->AppendNtSystemFilePathUtil(moduleName, &ntModuleName[0]))
		{
			CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Failed To append Nt SystemPath To Dll Name"))
			return false;
		}
		InitializeUnicodeString(uniStr.get(), ntModuleName.data());
	}
	else 
		InitializeUnicodeString(uniStr.get(), (PWSTR)moduleName);
	


	InitializeObjectAttributes(fileAtts.get(), uniStr.get(), OBJ_CASE_INSENSITIVE, nullptr, nullptr);
	
	auto pNtOpenFile = (fnNtOpenFile)this->FetchFunction(this->hashedNames.ntOpenFile);

	if (!NT_SUCCESS(status = pNtOpenFile(&hFile, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
		fileAtts.get(), ioStatus.get(), FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtOpenFile Failed With ERROR"), U_PTR(status))

		if (hFile) pNtCLose(hFile);
		return false;
	}
	
	
	auto pNtQueryInformationFile = (fnNtQueryInformationFile)this->FetchFunction(this->hashedNames.ntQueryInformationFile);
	
	if (!NT_SUCCESS(status = pNtQueryInformationFile(hFile, ioStatus.get(), fileStdInfo.get(),
		sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtQueryInformationFile Failed With ERROR"), U_PTR(status))

		if (hFile) pNtCLose(hFile);
		return false;
	}

	std::size_t szAlloc = fileStdInfo.get()->AllocationSize.QuadPart;
	std::size_t length = szAlloc;

	
	auto pNtAllocateVirtualMemory = (fnNtAllocateVirtualMemory)this->FetchFunction(this->hashedNames.ntAllocateVirtualMemory);

	void* allocatedMem = nullptr;

	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), &allocatedMem, 0, &szAlloc, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))

		if (hFile) pNtCLose(hFile);
		return false;
	}

	
	auto pNtReadFile = (fnNtReadFile)(this->FetchFunction(this->hashedNames.ntReadFile));
	
	if (!NT_SUCCESS(status = pNtReadFile(hFile, NULL, NULL,
		NULL, ioStatus.get(), allocatedMem, length, NULL, NULL)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtReadFile Failed With ERROR"), U_PTR(status))

		this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
		return false;
	}


	auto dos_Header = (PIMAGE_DOS_HEADER)((PBYTE)allocatedMem);
	if (dos_Header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Failed Dos Signature Check"))
		this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
		return false;
	}

	auto nt_Header = (PIMAGE_NT_HEADERS64)(((PBYTE)allocatedMem) + dos_Header->e_lfanew);
	if (nt_Header->Signature != IMAGE_NT_SIGNATURE)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Failed Nt Signature Check"))
		this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
		return false;
	}

	length = nt_Header->OptionalHeader.SizeOfImage;

	
	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), mappedModuleBase,
		0, &length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))

		this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
		return false;
	}

	
	std::memcpy(*mappedModuleBase, allocatedMem, nt_Header->OptionalHeader.SizeOfHeaders);

	
	auto sectionHeader = IMAGE_FIRST_SECTION(nt_Header);
	if (!sectionHeader)
	{
		this->MapLibCleanupUtil(hFile, mappedModuleBase, length);
		this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
	}

	for (auto i = 0; i < nt_Header->FileHeader.NumberOfSections; i++)
	{
		std::memcpy(C_PTR((U_PTR(*mappedModuleBase) + sectionHeader[i].VirtualAddress)),
			C_PTR((U_PTR(allocatedMem) + sectionHeader[i].PointerToRawData)),
			sectionHeader[i].SizeOfRawData);
	}


	this->MapLibCleanupUtil(hFile, &allocatedMem, szAlloc);
	IMAGE_ALLOC tempInfo = { nullptr };

	tempInfo.allocPtr = *mappedModuleBase;
	tempInfo.szAlloc = length;
	tempInfo.imageName = moduleName;

	*szFile = length;
	
	this->imageAllocationInfo.push_back(tempInfo);

	std::cout << xorstr_("Successful\n");

	return true;
}


void LibraryLoader::MapLibCleanupUtil(HANDLE fileHandle, void** Buffer, std::size_t szBuffer)
{
	NTSTATUS status = 1;

	auto pNtCLose = (fnNtCLose)this->FetchFunction(this->hashedNames.ntClose);

	if (fileHandle) pNtCLose(fileHandle);

	auto pNtFreeVirtualMemory = (fnNtFreeVirtualMemory)this->FetchFunction(this->hashedNames.ntFreeVirtualMemory);
	if (!NT_SUCCESS(status = pNtFreeVirtualMemory(NtCurrentProcess(), Buffer, &szBuffer, MEM_RELEASE)))
	{
		CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("NtFreeVirtualMemory Failed With ERROR"), U_PTR(status))
	}
}





bool LibraryLoader::ProcessImage(__in void* moduleImage, __in int fileFlag, __in int loadFlag)
{
	CPrint(xorstr_("Library Loader"), xorstr_("Checking Image Type"))
	
	if (!moduleImage)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Process Image; Invalid Parameter"))
		return false;
	}

	
	auto dosHeader = (PIMAGE_DOS_HEADER)((PBYTE)moduleImage);
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Process Image; Failed Dos Signature Check"))
		return false;
	}

	auto ntHeader = (PIMAGE_NT_HEADERS64)(((PBYTE)moduleImage) + dosHeader->e_lfanew);
	if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Process Image;  Failed Nt Signature Check"))
		return false;
	}

	
	
	CPrint(xorstr_("Library Loader"), xorstr_("Attempting To Process New dll"))

	auto relocDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (relocDir->VirtualAddress)
	{
		auto szImage = ntHeader->OptionalHeader.SizeOfImage;
		auto imageBase = C_PTR(ntHeader->OptionalHeader.ImageBase);
		auto relocTableOffset = C_PTR((U_PTR(moduleImage) + relocDir->VirtualAddress));
		if (!this->ProcessRelocs(moduleImage, szImage, imageBase, relocTableOffset, relocDir->Size))
		{
			return false;
		}

		CPrintBland(xorstr_("Successful\n"))

	}
	else
	{
		CPrintWarning(xorstr_("Library Loader"), xorstr_("Image Has No Relocations To Process"))
	}


	auto iatDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (iatDir->VirtualAddress)
	{
		auto iatTableOffset = C_PTR((U_PTR(moduleImage) + iatDir->VirtualAddress));
		if (!this->ProcessIat(moduleImage, iatTableOffset))
		{
			return false;
		}

		CPrintBland(xorstr_("Successful\n"))
	}
	else
	{
		CPrintWarning(xorstr_("Library Loader"), xorstr_("Image Has No Imports To Process"))
	}


	auto dlyDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
	if (dlyDir->VirtualAddress)
	{
		auto dlyImportsTableOffset = C_PTR((U_PTR(moduleImage) + dlyDir->VirtualAddress));
		if (!this->ProcessDelayedImports(moduleImage, dlyImportsTableOffset))
		{
			return false;
		}

		CPrintBland(xorstr_("Successful\n"))
	}
	else
	{
		CPrintWarning(xorstr_("Library Loader"), xorstr_("Image Has No Delayed Imports To Process"))
	}


	auto sehDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
	if (sehDir->VirtualAddress)
	{
		auto exceptionTableOffset = C_PTR((U_PTR(moduleImage) + sehDir->VirtualAddress));
		if (!this->ProcessSeh(moduleImage, exceptionTableOffset))
		{
			return false;
		}

		CPrintBland(xorstr_("Successful\n"))
	}
	else
	{
		CPrintWarning(xorstr_("Library Loader"), xorstr_("Image Has No Exceptions To Process"))
	}


	auto tlsDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if (tlsDir->VirtualAddress)
	{
		auto tlsTableOffset = C_PTR((U_PTR(moduleImage) + tlsDir->VirtualAddress));
		if (!this->ProcessTlsCallbacks(moduleImage, tlsTableOffset))
		{
			return false;
		}

		CPrintBland(xorstr_("Successful\n"))
	}
	else
	{
		CPrintWarning(xorstr_("Library Loader"), xorstr_("Image Has No Tls Callbacks To Process"))
	}


	if (loadFlag == LoadWithExecute)
	{
		if (ntHeader->OptionalHeader.AddressOfEntryPoint == 0) return false - 1;

		auto entryPoint = (DLLMAIN)OffsetToPointer(moduleImage, ntHeader->OptionalHeader.AddressOfEntryPoint);

		if (!entryPoint((HINSTANCE)moduleImage, DLL_PROCESS_ATTACH, (LPVOID)NULL))
		{
			return false - 2;
		}

		CPrint(xorstr_("Library Loader"), xorstr_("Successfully Executed Dll"))
	}	
	

	
	return true;
}





bool LibraryLoader::ProcessIat(__in void* moduleImage, __in void* DirectoryTable)
{
	auto Iat = (PIMAGE_IMPORT_DESCRIPTOR)DirectoryTable;
	auto uniStr = UNICODE_STRING { 0 };
	auto ansStr = ANSI_STRING { 0 };
	void* moduleBase = nullptr;
	NTSTATUS status = 1;
	std::wstring uniName; uniName.reserve(MAX_PATH);
	std::wstring resName; resName.reserve(MAX_PATH);
	std::string name;

	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Import Address Table..."))

	if (!moduleImage || !DirectoryTable)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Process Iat; Invalid Parameter"))
		return false;
	}
	



	for (; Iat->Name; Iat++)
	{
		
		name = (char*)(C_PTR(((U_PTR(moduleImage)) + Iat->Name)));

		uniName.clear();
		RtlZeroMemory(&uniStr, sizeof(uniStr));
		RtlZeroMemory(&ansStr, sizeof(ansStr));
		
		
		
		if (!this->StringConversionUtil(&uniName[0], name))
		{
			break;
		}

		moduleBase = this->PebModuleUtil(Rsh.Hash_String(uniName.data()));
		if(!moduleBase)
		{
			
			if (this->ApiStringCompare(uniName))
			{
				
				if (!this->ResolveApiSet(uniName, &resName[0])) goto LdrLoad;

				moduleBase = this->PebModuleUtil(Rsh.Hash_String(resName));
				if (!moduleBase)
				{	
					InitializeUnicodeString(&uniStr, resName.data());
					goto LdrLoad;
				}
			}
			else
			{
			LdrLoad:
					
				if (!uniStr.Buffer)
				{
					InitializeUnicodeString(&uniStr, uniName.data());
				}
				
					
				auto pLdrLoadDll = (fnLdrLoadDll)this->FetchFunction(this->hashedNames.LdrLoadDll);

				if (!NT_SUCCESS(status = pLdrLoadDll(NULL, 0, &uniStr, &moduleBase)))
				{
					CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("LdrLoadDll Failed With ERROR"), U_PTR(status))
					break;
				}

				RtlZeroMemory(&uniStr, sizeof(uniStr));
				resName.clear();

			}
		}
		
		if (moduleBase)
		{

			void* function = nullptr;

			auto pLdrGetProcedureAddress = (fnLdrGetProcedureAddress)this->FetchFunction(this->hashedNames.LdrGetProcedureAddress);
			
			
			auto originThunk = (PIMAGE_THUNK_DATA64)(C_PTR((U_PTR(moduleImage) + Iat->OriginalFirstThunk)));
			auto firstThunk = (PIMAGE_THUNK_DATA64)(C_PTR((U_PTR(moduleImage) + Iat->FirstThunk)));

			for (; originThunk->u1.AddressOfData; ++originThunk, ++firstThunk)
			{
				
				if (IMAGE_SNAP_BY_ORDINAL64(originThunk->u1.Ordinal))
				{
				
					if (!NT_SUCCESS(status = pLdrGetProcedureAddress((HMODULE)moduleBase, NULL,
						IMAGE_ORDINAL64(originThunk->u1.Ordinal), &function)))
					{		
						break;
					}
				}
				else
				{
					
					name = ((PIMAGE_IMPORT_BY_NAME)C_PTR((U_PTR(moduleImage) + originThunk->u1.AddressOfData)))->Name;

					InitializeAnsiString(&ansStr, name.data());

					if (!NT_SUCCESS(status = pLdrGetProcedureAddress((HMODULE)moduleBase, &ansStr, 0, &function)))
					{
						break;
					}
					
				}

				firstThunk->u1.Function = U_PTR(function);
			}
		}
	}

	return true;
}



bool LibraryLoader::ProcessDelayedImports(__in void* moduleImage, __in void* DirectoryTable)
{
	auto dlyImports = (PIMAGE_DELAYLOAD_DESCRIPTOR)DirectoryTable;
	auto uniStr = UNICODE_STRING{ 0 };
	auto ansStr = ANSI_STRING{ 0 };
	NTSTATUS status = 1;
	void* moduleBase = nullptr;
	std::wstring resName; resName.reserve(MAX_PATH);
	std::wstring uniName; uniName.reserve(MAX_PATH);
	std::string name;


	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Delayed Imports..."))

	if (!moduleImage || !DirectoryTable)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Process Delayed Imports; Invalid Parameter"))
		return false;
	}
	




	for (; dlyImports->DllNameRVA; dlyImports++)
	{
		
		name = (char*)(C_PTR(((U_PTR(moduleImage)) + dlyImports->DllNameRVA)));
		

		uniName.clear();
		RtlZeroMemory(&uniStr, sizeof(uniStr));
		RtlZeroMemory(&ansStr, sizeof(ansStr));


		if (!this->StringConversionUtil(&uniName[0], name))
		{
			break;
		}


		moduleBase = this->PebModuleUtil(Rsh.Hash_String(uniName));
		if (!moduleBase)
		{
			
			if (this->ApiStringCompare(uniName))
			{
				
				if (!this->ResolveApiSet(uniName, &resName[0])) goto LdrLoad;


				moduleBase = this->PebModuleUtil(Rsh.Hash_String(resName));
				if (!moduleBase)
				{
					InitializeUnicodeString(&uniStr, resName.data());
					goto LdrLoad;
				}
			}
			else
			{		
			LdrLoad:

				if (!uniStr.Buffer)
				{
					InitializeUnicodeString(&uniStr, uniName.data());
				}

			


				auto pLdrLoadDll = (fnLdrLoadDll)this->FetchFunction(this->hashedNames.LdrLoadDll);

				if (!NT_SUCCESS(status = pLdrLoadDll(NULL, 0, &uniStr, &moduleBase)))
				{
					CAppendedPrintErrorCode(xorstr_("Library Loader"), xorstr_("LdrLoadDll Failed With ERROR"), U_PTR(status))
					break;
				}

				RtlZeroMemory(&uniStr, sizeof(uniStr));
				resName.clear();
			}
		}

		if (moduleBase)
		{
			void* function = nullptr;

			auto pLdrGetProcedureAddress = (fnLdrGetProcedureAddress)this->FetchFunction(this->hashedNames.LdrGetProcedureAddress);


			auto originThunk = (PIMAGE_THUNK_DATA64)(C_PTR((U_PTR(moduleImage) + dlyImports->ImportNameTableRVA)));
			auto firstThunk = (PIMAGE_THUNK_DATA64)(C_PTR((U_PTR(moduleImage) + dlyImports->ImportAddressTableRVA)));

			for (; originThunk->u1.AddressOfData; originThunk++, firstThunk++)
			{
				if (IMAGE_SNAP_BY_ORDINAL64(originThunk->u1.Ordinal))
				{

					if (!NT_SUCCESS(status = pLdrGetProcedureAddress((HMODULE)moduleBase, NULL,
						IMAGE_ORDINAL64(originThunk->u1.Ordinal), &function)))
					{
						break;
					}
				}
				else
				{
					name = ((PIMAGE_IMPORT_BY_NAME)C_PTR((U_PTR(moduleImage) + originThunk->u1.AddressOfData)))->Name;

					InitializeAnsiString(&ansStr, name.data());


					if (!NT_SUCCESS(status = pLdrGetProcedureAddress((HMODULE)moduleBase, &ansStr, 0, &function)))
					{
						break;
					}
				}

				firstThunk->u1.Function = U_PTR(function);
			}
		}
	}
	return true;
}




bool LibraryLoader::ProcessTlsCallbacks(__in void* moduleImage, __in void* DirectoryTable)
{

	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Tls Callbacks..."))

	if (!moduleImage || DirectoryTable)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("ProcessTlsCallbacks; Invalid Parameter"))
		return false;
	}



	auto tlsDir = (PIMAGE_TLS_DIRECTORY)(DirectoryTable);

	auto tlsCallbacks = (PIMAGE_TLS_CALLBACK*)tlsDir->AddressOfCallBacks;

	if (!tlsCallbacks) return false;

	while (*tlsCallbacks)
	{
		(*tlsCallbacks)(moduleImage, DLL_PROCESS_ATTACH, nullptr);
	}

	return true;
}


bool LibraryLoader::ProcessRelocs(__in void* moduleImage, __in DWORD szModuleImage, __in void* moduleBase, __in void* DirectoryTable, __in DWORD szDirectoryTable)
{
	
	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Base Relocations..."))

	if (!moduleImage || !DirectoryTable || !szModuleImage || !szDirectoryTable)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("ProcessRelocs; Invalid Parameter"))
		return false;
	}


	auto offset = PointerToOffset(moduleImage, moduleBase);

	auto baseReloc = (PIMAGE_BASE_RELOCATION)(DirectoryTable);
	

	while (U_PTR(U_PTR(baseReloc) < U_PTR(U_PTR(moduleImage) + U_PTR(DirectoryTable) + szDirectoryTable)) &&
	U_PTR(baseReloc->VirtualAddress != 0))
	{
		auto endOfReloc = C_PTR((U_PTR(baseReloc) + baseReloc->SizeOfBlock));
		auto reloc = C_PTR((U_PTR(baseReloc) + 1));
		
		while (reloc < endOfReloc)
		{
			
			auto address = C_PTR(U_PTR(baseReloc->VirtualAddress + ((PIMAGE_RELOC)reloc)->Offset));

			if (U_PTR(address) < szModuleImage)
			{
				auto data = (PIMAGE_RELOC)reloc;
				address = C_PTR((U_PTR(moduleImage) + baseReloc->VirtualAddress + data->Offset));

				
				if (data->Type == IMAGE_REL_BASED_HIGH) C_DEF64(address) += HIWORD(offset);
				else if (data->Type == IMAGE_REL_BASED_LOW) C_DEF64(address) += LOWORD(offset);
				else if (data->Type == IMAGE_REL_BASED_DIR64) C_DEF64(address) += U_PTR64(offset);
				else if (data->Type == IMAGE_REL_BASED_HIGHLOW) C_DEF32(address) += U_PTR32(offset);
			}

			reloc = static_cast<PBYTE>(reloc) + 1;
		}

		baseReloc = (PIMAGE_BASE_RELOCATION)reloc;
	}

	return true;
}


bool LibraryLoader::ProcessSeh(__in void* moduleImage, __in void* DirectoryTable)
{

	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Exceptions..."))

	if (!moduleImage || !DirectoryTable)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("ProcessSeh; Invalid Parameter"))
		return false;
	}


	auto pRtlAddFunctionTable = (fnRtlAddFunctionTable)this->FetchFunction(this->hashedNames.RtlAddFunctionTable);

	auto count = (((PIMAGE_DATA_DIRECTORY)DirectoryTable)->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1;

	if (!pRtlAddFunctionTable((PRUNTIME_FUNCTION)DirectoryTable, count, U_PTR(moduleImage)))
	{
		return false;
	}

	return true;
}



bool LibraryLoader::ResolveApiSet(__in std::wstring apiSetName, __in void* apiSetRestore)
{

	if (!apiSetName.empty() || !apiSetRestore)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Rsolve Api Set; Invalid Parameter"))
		return false;
	}
	



	auto peb = (PPEB64)__readgsqword(0x60);
	auto apiSetMap = (PAPI_SET_NAMESPACE_ARRAY_V2)peb->ApiSetMap;

	if (apiSetMap->Version == API_SET_VERSION_V6)
	{
		return this->ResolveApiSetv6(apiSetName, apiSetRestore);
	}
	else
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_(" Unsupported API Set"))
	
	return false;
}




bool LibraryLoader::ResolveApiSetv6(__in std::wstring apiSetNamev6, __in void* apiSetRestorev6)
{
	if (!apiSetNamev6.empty() || !apiSetRestorev6)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("Rsolve Api Setv6; Invalid Parameter"))
		return false;
	}
	

	auto peb = (PPEB64)__readgsqword(0x60);
	auto apiSetMap = (PAPI_SET_NAMESPACE_ARRAY_V6)peb->ApiSetMap;

	for (auto i = 0; i < apiSetMap->Count; i++)
	{
		auto apiEntry = &apiSetMap->Array[i];
		auto entryName = (wchar_t*)(C_PTR((U_PTR(apiSetMap) + apiEntry->NameOffset)));
		auto apiArray = (PAPI_SET_VALUE_ENTRY_V6)(C_PTR((U_PTR(apiSetMap) + apiEntry->DataOffset)));

		
		if (std::wcscmp(apiSetNamev6.c_str(), entryName) != 0) continue;

		
		for (auto j = 0; j < apiEntry->Count; j++)
		{
			auto apiValueEntry = &apiArray[j];
			auto apiValue = (wchar_t*)(C_PTR((U_PTR(apiSetMap) + apiValueEntry->ValueOffset)));

			if (apiValueEntry->NameLength == 0)
			{
				std::memcpy(apiSetRestorev6, apiValue, (apiValueEntry->ValueLength * sizeof(wchar_t) + 2));
				
				return true;
			}

		}
	}

	return false;
}





void* LibraryLoader::PebModuleUtil(__in std::uint32_t hashedModuleName)
{
	auto peb = (PPEB64)__readgsqword(0x60);
	PLDR_DATA_TABLE_ENTRY64 entry = nullptr;


	auto pLdr = (PPEB_LDR_DATA64)peb->Ldr;
	if (!pLdr)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Failed To Fetch Peb"))
		return nullptr;
	}

	auto ldrEntry = (PLDR_DATA_TABLE_ENTRY64)pLdr->InMemoryOrderModuleList.Flink;
	if (!ldrEntry)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Failed To Fetch Ldr Entry"))
		return nullptr;
	}

	do
	{
		if (ldrEntry->BaseDllName.Buffer == nullptr) break;
		else
		{
			entry = CONTAINING_RECORD(ldrEntry, LDR_DATA_TABLE_ENTRY64, InMemoryOrderLinks);
		}


		if (Rsh.String_cmp(hashedModuleName, entry->BaseDllName.Buffer))
		{
			return entry->DllBase;
		}


		ldrEntry = *(PLDR_DATA_TABLE_ENTRY64*)(ldrEntry);

	} while (ldrEntry);


	return nullptr;
}



void* LibraryLoader::FunctionAddrUtil(__in void* mappedBase, __in std::uint32_t hashedModuleName, __in std::uint32_t hashedProcName)
{
	
	PBYTE pBase = nullptr;

	if (!mappedBase)
	{

		if (!hashedModuleName)
		{
			CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Invalid Parameter, Must Provide A Image Base or Hashed Module Name"))
			return nullptr;
		}

		pBase = (PBYTE)this->PebModuleUtil(hashedModuleName);
	}
	else
	{
		pBase = (PBYTE)mappedBase;
	}
	
	
	if (!hashedProcName)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Invalid Parameter, Must Provide Hashed Procedure Name"))
		return nullptr;
	}



	auto dos_Header = (PIMAGE_DOS_HEADER)pBase;
	if (dos_Header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Failed DOS Signature Check"))
		return nullptr;
	}

	auto nt_Header = (PIMAGE_NT_HEADERS64)(pBase + dos_Header->e_lfanew);
	if (nt_Header->Signature != IMAGE_NT_SIGNATURE)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Failed NT Signature Check"))
		return nullptr;
	}

	if ((nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Failed To Find Image Directory Entry Point"))
		return nullptr;
	}

	auto szExportDir = nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	auto exportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (!exportDir)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Failed To Fetch Export Directory"))
		return nullptr;
	}



	auto  nameArray = (PDWORD)(pBase + exportDir->AddressOfNames);
	auto  ordinal = (PWORD)(pBase + exportDir->AddressOfNameOrdinals);
	auto  addressArray = (PDWORD)(pBase + exportDir->AddressOfFunctions);

	for (DWORD i = 0; i < exportDir->NumberOfNames; i++)
	{
		auto name = (char*)(pBase + nameArray[i]);
		auto pFunctionAddress = (void*)(pBase + addressArray[ordinal[i]]);


		if (name && Rsh.String_cmp(hashedProcName, name) == true)
		{
			return pFunctionAddress;
		}
	}

	CPrintError(xorstr_("Library Loader"), xorstr_("FunctionAddrUtil; Failed To Find Function Address"))
	return nullptr;
}



/// <summary>
/// all structure variables must be the same
/// </summary>
template <typename S> std::uint32_t* GetBegin(S* structure)
{
	return (std::uint32_t*)(std::uint32_t*)structure;
}

template <typename S> std::uint32_t* GetEnd(S* structure)
{
	auto varCount = (sizeof(*structure) / sizeof(std::uint32_t)) -1;
	return (std::uint32_t*)((std::uint32_t*)structure + varCount);
}



bool LibraryLoader::FetchFunctionPtrsUtil()
{
	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Fetching All Function Pointers..."))

	auto tempPtrs = FUNCTION_PTRS { nullptr };
	std::uint32_t nonPtr;

	for (auto ptr = GetBegin(&this->hashedNames); ptr < GetEnd(&this->hashedNames) + 1; ptr++)
	{
		nonPtr = *ptr;

		tempPtrs.function_Ptr = this->FunctionAddrUtil(nullptr, this->ntdllHash, nonPtr);
		tempPtrs.hashedName = nonPtr;

		if (!tempPtrs.function_Ptr)
		{
			return false;
		}

		this->functionPointers.push_back(tempPtrs);
	}

	CPrintBland(xorstr_("Success\n"));
	return true;
}



void LibraryLoader::LibraryLoader::CleanupUtil()
{
	
	for (auto& it : this->imageAllocationInfo)
	{
		if (it.allocPtr && it.szAlloc)
		{
			this->MapLibCleanupUtil(nullptr, &it.allocPtr, it.szAlloc);
		}
		
	}
}



bool LibraryLoader::FetchSystemPathUtil()
{
	
	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Fetching System File Path..."))

	PWSTR systemPath = nullptr;
	HRESULT status = 1;
	
	if (HR_SUCCESS(status = SHGetKnownFolderPath(FOLDERID_System, KF_FLAG_DEFAULT_PATH, nullptr, &systemPath)))
	{
		this->SystemFilePath.append(systemPath);
		this->SystemFilePath.append(xorstr_(L"\\"));
	}
	else
	{
		CPrintBland(xorstr_("Unsuccessful\n"))
		return false;
	}

	CPrintBland(xorstr_("Success\n"))
	return true;
}




bool LibraryLoader::AppendNtSystemFilePathUtil(__in const wchar_t* moduleName, __in void* ntModuleName)
{
	
	std::wstring filePath = LibraryLoader::SystemFilePath;

	filePath.append(moduleName);
	
	if (filePath.empty())
	{
		return false;
	}

	std::memcpy(ntModuleName, filePath.c_str(), (filePath.length() * sizeof(wchar_t)) + 2);

	filePath.clear();
 
	return true;		
}



template<typename input>
bool LibraryLoader::StringConversionUtil(__in void* destination, __in  input source)
{
	if constexpr (std::is_same_v<input,std::string>)
	{
		std::wstring wConversion(source.begin(), source.end());

		std::memcpy(destination, wConversion.c_str(), (wConversion.size() * sizeof(wchar_t) + 2));

		if (std::wcscmp(reinterpret_cast<const wchar_t*>(destination), wConversion.c_str()) == 0) return true;
	}

	if constexpr (std::is_same_v<input, std::wstring>)
	{
		std::string aConversion(source.begin(), source.end());

		std::memcpy(destination, aConversion.c_str(), (aConversion.size() * sizeof(char) + 1));

		if (std::strcmp(reinterpret_cast<const char*>(destination), aConversion.c_str()) == 0) return true;
	}
	
	return false;
}



bool LibraryLoader::ApiStringCompare(__in std::wstring apiModuleName)
{
	
	for (std::size_t i = 0; i < 4; i++)
	{
		if (this->apiString.data()[i] == apiModuleName.data()[i]) continue;

		return false;
	}

	return true;
}


void* LibraryLoader::FetchFunction(std::uint32_t hashedName)
{

	for (auto& it : functionPointers)
	{
		if (Rsh.Hash_Compare(hashedName, it.hashedName)) return it.function_Ptr;
	}


	return nullptr;
}



bool LibraryLoader::ProcessExecutable(__in void* moduleImage)
{

	if (!moduleImage)
	{
		CAppendedPrintError(xorstr_("Library Loader"), xorstr_("ProcessRelocs; Invalid Parameter"))
			return false;
	}
	auto dosHeader = (PIMAGE_DOS_HEADER)((PBYTE)moduleImage);
	auto ntHeader = (PIMAGE_NT_HEADERS64)((PBYTE)moduleImage + dosHeader->e_lfanew);
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE && ntHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		CPrintError(xorstr_("Library Loader"), xorstr_("Image Failed Portable Execuatable Check"));
		return false;
	}

	if (ntHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)
		CPrint(xorstr_("Library Loader"), xorstr_("Processing New Executable"))

	if (ntHeader->FileHeader.Characteristics & IMAGE_FILE_SYSTEM)
		CPrint(xorstr_("Library Loader"), xorstr_("Processing New System File"))


	CAppendedPrint(xorstr_("Library Loader"), xorstr_("Processing Base Relocations..."))


	auto relocDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	auto szRelocDir = relocDir->Size;
	auto baseOffset = PointerToOffset(moduleImage, ntHeader->OptionalHeader.ImageBase);

	if (relocDir->VirtualAddress)
	{
		auto baseReloc = (PIMAGE_BASE_RELOCATION)C_PTR((U_PTR(moduleImage) + relocDir->VirtualAddress));

		for (std::uint32_t currentSize = 0; currentSize < szRelocDir; )
		{

			ULONG relocCount = (baseReloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(std::uint_fast16_t);
			std::uint_fast16_t* relocData = (std::uint_fast16_t*)((PBYTE)baseReloc + sizeof(IMAGE_BASE_RELOCATION));

			for (std::uint32_t i = 0; i < relocCount; ++i, ++relocData)
			{
				auto Data = *relocData;
				std::uint_fast16_t Type = Data >> 12;
				std::uint_fast16_t Offset = Data & 0xFFF;

				auto address = C_PTR((U_PTR(moduleImage) + (baseReloc->VirtualAddress + Offset)));


				if (Type == IMAGE_REL_BASED_ABSOLUTE) {}
				else if (Type == IMAGE_REL_BASED_DIR64) C_DEF64(address) += U_PTR64(baseOffset);
				else if (Type == IMAGE_REL_BASED_HIGH) C_DEF64(address) += HIWORD(baseOffset);
				else if (Type == IMAGE_REL_BASED_LOW) C_DEF64(address) += LOWORD(baseOffset);
				else if (Type == IMAGE_REL_BASED_HIGHLOW) C_DEF32(address) += U_PTR32(baseOffset);
			}

			currentSize += baseReloc->SizeOfBlock;
			baseReloc = (PIMAGE_BASE_RELOCATION)relocData;
		}	
	}




	return true;
}



