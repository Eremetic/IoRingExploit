#pragma once
#include <Windows.h>
#include <string>
#include <vector>

#include "Framework.hpp"


class ProcessInit
{
private:
    std::vector<HOOKED_TEXT> oldTextScetions{};
    std::vector<IMAGE_INFO> imageInfo{};
    std::vector<FUNCTION_PTRS> functionPointers{};
    std::vector<MAPPED_INFO> mappedPointers{}; 
    /// <summary>
    /// For any dlls Being Used
    /// </summary>
    std::uint32_t ntdllHash;
    std::uint32_t kernel32Hash;
    std::uint32_t kernelbaseHash;
    std::uint32_t advapiHash;
    std::uint32_t ucrtHash;
    std::uint32_t user32Hash;
    std::uint32_t sechostHash;
    std::uint32_t imm32Hash;
    /// <summary>
    /// For Any Functions Being Used
    /// </summary>
    struct ntdllFunctions
    { 
        
        std::uint32_t ntOpenSectionHash;
        std::uint32_t ntOpenProcessHash;
        std::uint32_t ntOpenProcessTokenHash;
        std::uint32_t ntAllocateVirtualMemoryHash;
        std::uint32_t ntFreeVirtualMemoryHash;
        std::uint32_t ntDuplicateTokenHash;
        std::uint32_t ntSetInformationThreadHash;
        std::uint32_t ntOpenFileHash;
        std::uint32_t ntCloseHash;

    }ntdllhashedNames;

    struct kernel32Functions
    {
        
        std::uint32_t MapViewOfFileHash;
        std::uint32_t UnmapViewOfFileHash;
        std::uint32_t setConsoleTitleAHash;
        std::uint32_t VirtualProtectHash;
        std::uint32_t CreateFileMappingWHash;
        std::uint32_t ProcessSnapshotHash;
        std::uint32_t Process32NextWHash;
        std::uint32_t Process32FirstWHash;

    }kernel32hashedNames;

    std::uint32_t AdjustTokenPrivilegesHash;
    
     
    /// <summary>
    /// process name hashes
    /// </summary>
    std::uint32_t winlogonHash;
    std::uint32_t servicesHash;
    std::uint32_t wininitHash;

    

    void Map_Dll(__out void** pBuffer, __in wchar_t* Knowndll);
    bool Text_Section_Swap(__in wchar_t* KnownDll, __in std::uint32_t Sys32Dll);
    bool UnHook_Dlls(__in int name);
    void IatCamouflage();
    bool Dll_Info();
    bool Window_Title(); 
    inline std::string Filepath_To_Filename(const wchar_t* String);
    void* Function_Addr(__in std::uint32_t hashedModuleName, __in std::uint32_t hashedProcName);
    void* Retrive_DllBase(__in std::uint32_t hashedModule);
   
    bool Hijack_token();
    void* Fetch_Process_By_Name(const std::uint32_t procssNameHash);
    bool FetchFunctionPtrsUtil();
    void* Fetch_Function(std::uint32_t hashedName);
    bool Init();
    void Cleanup();

public:

    ::ProcessInit(bool* initCheck)
    {
        if (!this->Init())
        {
            *initCheck = false;
            return;
        }

        *initCheck = true;
    }

    ~ProcessInit()
    {
        this->Cleanup();
    }
};


using fnAdjustTokenPrivileges = BOOL (__stdcall*)(HANDLE, BOOL, PTOKEN_PRIVILEGES, DWORD, PTOKEN_PRIVILEGES, PDWORD);

using fnNtOpenProcessToken = NTSTATUS (__fastcall*)(HANDLE, DWORD, PHANDLE);

using fnNtDuplicateToken = NTSTATUS (__fastcall*)(HANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, BOOLEAN, TOKEN_TYPE, PHANDLE);

using fnNtSetInformationThread = NTSTATUS(__fastcall*)(HANDLE, THREADINFOCLASS, PVOID, ULONG);

using fnNtOpenSection = NTSTATUS (__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);

using fnNtAllocateVirtualMemory = NTSTATUS(__fastcall*)(HANDLE, PVOID*, DWORD64, PSIZE_T, DWORD, DWORD);

using fnNtFreeVirtualMemory = NTSTATUS(__fastcall*)(HANDLE, PVOID, PSIZE_T, DWORD);

using fnMapViewOfFile = LPVOID (__stdcall*)(HANDLE, DWORD, DWORD, DWORD, SIZE_T);

using fnUnmapViewOfFile = BOOL(__stdcall*)(LPVOID);

using fnVirtualProtect = BOOL (__stdcall*)(LPVOID, SIZE_T, DWORD, PDWORD);

using fnSetConsoleTitleA = BOOL (__stdcall*)(LPCTSTR);

using fnCreateFileMappingW = HANDLE (__stdcall*)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPWSTR);

using fnNtOpenFile = NTSTATUS (__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, DWORD, DWORD);

using fnCreateToolhelp32Snapshot = HANDLE (__stdcall*)(DWORD, DWORD);

using fnNtOpenProcess = NTSTATUS (__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, CLIENT_ID*);

using fnNtCLose = NTSTATUS (__fastcall*)(HANDLE);

using fnProcess32NextW = BOOL (__stdcall*)(HANDLE, LPPROCESSENTRY32W);
using fnProcess32FirstW = BOOL (__stdcall*)(HANDLE, LPPROCESSENTRY32W);


