#pragma once
#include <Windows.h>
#include <typeinfo>
#include <type_traits>
#include <vector>



#define HASHSTRA( X ) Rsh.Hash_String<const char*>( X )
#define HASHSTRW( X ) Rsh.Hash_String<const wchar_t*>( X )

class Hasher
{
private:
	const std::uint32_t INITIAL_HASH = 5381;
	const std::uint32_t INITIAL_SEED = 5;
	std::uint32_t KeyXorObf = 0;

	static std::uint32_t RS_Sub(__in std::uint32_t Value, __in std::uint32_t Count)
	{
		DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
		Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
		return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
	}


	static constexpr ULONG ExprXorKey(VOID)
	{
		return '0' * -40271 +
			__TIME__[7] * 1 +
			__TIME__[6] * 10 +
			__TIME__[4] * 60 +
			__TIME__[3] * 600 +
			__TIME__[1] * 3600 +
			__TIME__[0] * 36000;
	}

	static constexpr uint32_t modulus()
	{
		return 0x7fffffff;
	}

	template<size_t N>
	static constexpr uint32_t seed(__in const char(&entropy)[N], __in const uint32_t iv = 0)
	{
		auto value{ iv };
		for (size_t i{ 0 }; i < N; i++) {

			value = (value & ((~0) << 8)) | ((value & 0xFF) ^ entropy[i]);

			value = value << 8 | value >> ((sizeof(value) * 8) - 8);
		}

		while (value > modulus()) value = value >> 1;
		return value << 1 | 1;
	}


public:

	///Constructor
	::Hasher()
	{
		this->KeyXorObf = this->seed(__FILE__, this->ExprXorKey());
	}


	template<typename T>
	bool String_cmp(std::uint32_t hashedString, T String)
	{
		std::uint32_t S_hashValue = 0;

			if constexpr (std::is_same_v<T, wchar_t*> || std::is_same_v<T, const wchar_t*>)
			{
				S_hashValue = this->Hash_String(String);
			}
			else if constexpr (std::is_same_v<T, char*> || std::is_same_v<T, const char*>)
			{
				S_hashValue = this->Hash_String(String);
			}
			else
				return false;

		
		if (this->Hash_Compare(hashedString, S_hashValue)) return true;
		
		return false;
	}
	
	
	template<typename T>
	const std::uint32_t Hash_String(__in T String)
	{
		std::uint32_t hashValue = 0;
		

		if constexpr (std::is_same_v<T, wchar_t*> || std::is_same_v<T, const wchar_t*>)
		{
			for (int i = 0; i < lstrlenW(String); i++)
			{
				hashValue = String[i] + RS_Sub(hashValue, Hasher::KeyXorObf);
			}
		}
		else if constexpr (std::is_same_v<T, char*> || std::is_same_v<T, const char*>)
		{
			for (int i = 0; i < lstrlenA(String); i++)
			{
				hashValue = String[i] + RS_Sub(hashValue, Hasher::KeyXorObf);
			}
		}
		else
			return 0;

		
		return hashValue;
	}
	
	
	template<typename T>
	bool RSHasher(__in T String1, __in T String2)
	{
		std::uint32_t S1_hashValue = 0;
		std::uint32_t S2_hashValue = 0;


		
		if constexpr (std::is_same_v<T, wchar_t*> || std::is_same_v<T, const wchar_t*>)
		{
			for (int i = 0; i < lstrlenW(String1); i++)
			{
				S1_hashValue = String1[i] + RS_Sub(S1_hashValue, Hasher::KeyXorObf);
			}

			for (int i = 0; i < lstrlenW(String2); i++)
			{
				S2_hashValue = String2[i] + RS_Sub(S2_hashValue, Hasher::KeyXorObf);
			}
		}
		else if constexpr (std::is_same_v<T, char*> || std::is_same_v<T, const char*>)
		{
			for (int i = 0; i < lstrlenA(String1); i++)
			{
				S1_hashValue = String1[i] + RS_Sub(S1_hashValue, Hasher::KeyXorObf);
			}

			for (int i = 0; i < lstrlenA(String2); i++)
			{
				S2_hashValue = String2[i] + RS_Sub(S2_hashValue, Hasher::KeyXorObf);
			}
		}
		else
			return false;

		
		
		if (this->Hash_Compare(S1_hashValue, S2_hashValue))
		{
			return true;
		}


		return false;
	}

	template<typename T, SIZE_T N>
	bool RSHasherSelect(__in T String1, __in T String2)
	{
		std::uint32_t S1_hashValue = 0;
		std::uint32_t S2_hashValue = 0;


		
		for (int i = 0; i < N; i++)
		{
			S1_hashValue = String1[i] + RS_Sub(S1_hashValue, Hasher::KeyXorObf);
		}

		for (int i = 0; i < N; i++)
		{
			S2_hashValue = String2[i] + RS_Sub(S2_hashValue, Hasher::KeyXorObf);
		}
		

		if (this->Hash_Compare(S1_hashValue, S2_hashValue))
		{
			return true;
		}


		return false;
	}

	
	inline bool Hash_Compare(__in std::uint32_t hash1, __in std::uint32_t hash2)
	{
		
		if (hash1 == hash2) return true;
		
		return false;
	}

	/// <summary>
	/// custom for my application
	/// </summary>
	/// <param name="const char* String"></param>
	/// <returns>hashed function name</returns>
	inline const auto Krnl_Hasher(__in const char* String)
	{
		std::uint32_t hashedString = 0;
		std::uint32_t c = 0;

		auto strLen = 0;
		auto len = 0;
		hashedString = Hasher::INITIAL_HASH;

		strLen = lstrlenA(String);

		while (len < strLen)
		{
			c = (std::uint32_t)String[len];
			hashedString = ((hashedString << Hasher::INITIAL_SEED) + hashedString) + c;

			len++;
		}


		return (hashedString & 0xFFFFFFFF);
	}

	
	
	template <typename T>
	inline constexpr auto CompileTime_Hash(T& String)
	{
		std::uint32_t S_hashValue = 0;


		if constexpr (std::is_same_v<T, const wchar_t*>)
		{
			for (int i = 0; i < lstrlenW(String); i++)
			{
				S_hashValue = String[i] + RS_Sub(S_hashValue, Hasher::KeyXorObf);
			}
		}
		else if constexpr (std::is_same_v<T, const char*>)
		{
			for (int i = 0; i < lstrlenA(String); i++)
			{
				S_hashValue = String[i] + RS_Sub(S_hashValue, Hasher::KeyXorObf);
			}

		}
		else
			return false;


		return S_hashValue;
	}
};


inline Hasher Rsh;





	






