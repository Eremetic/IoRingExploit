#pragma once
#include <Windows.h>
#include <string>
#include <vector>

#include "Framework.hpp"

class LibraryLoader
{
private:

    /// <summary>
    /// internal function pointers
    /// </summary>
    std::vector<FUNCTION_PTRS> functionPointers{}; 

    /// <summary>
    /// ntdll hash for functions
    /// </summary>
    std::uint32_t ntdllHash;
	
    /// <summary>
	/// function hash struct
	/// </summary>
	struct
	{
		std::uint32_t ntOpenFile;
		std::uint32_t ntReadFile;
		std::uint32_t ntQueryInformationFile;
		std::uint32_t ntAllocateVirtualMemory;
		std::uint32_t ntFreeVirtualMemory;
		std::uint32_t RtlAddFunctionTable;
		std::uint32_t ntClose; 
        std::uint32_t LdrLoadDll;
        std::uint32_t LdrGetProcedureAddress;

	}hashedNames;

    /// <summary>
    /// api/ext hash values for reloving apisets
    /// </summary>
    std::wstring apiString;
    std::wstring extString;

	/// <summary>
	/// vector with any allocated void*
	/// </summary>
    std::vector<IMAGE_ALLOC> imageAllocationInfo{};


	/// <summary>
	/// system32 file path
	/// </summary>
	std::wstring SystemFilePath;
   


	/// <summary>
	/// functions
	/// </summary>
    bool MapLibrary(__in const wchar_t* moduleName, __out void** mappedModuleBase, __in bool isFilePath, __out std::size_t* szFile);
	bool ProcessImage(__in void* moduleImage, __in int fileFlag, __in int loadFlag);
    bool ProcessRelocs(__in void* moduleImage, __in DWORD szModuleImage, __in void* moduleBase, __in void* DirectoryTable, __in DWORD szDirectoryTable);
	bool ProcessIat(__in void* moduleImage, __in void* DirectoryTable);
	bool ProcessDelayedImports(__in void* moduleImage, __in void* DirectoryTable);
	bool ProcessTlsCallbacks(__in void* moduleImage,  __in void* DirectoryTable);
	bool ProcessSeh(__in void* moduleImage, __in void* DirectoryTable);
	bool ResolveApiSet(__in std::wstring apiSetName, __in void* apiSetRestore);
    bool ResolveApiSetv6(__in std::wstring apiSetNamev6, __in void* apiSetRestorev6);
    bool ProcessExecutable(__in void* moduleImage);
	
    /// <summary>
	/// utility functions
	/// </summary>
	void MapLibCleanupUtil(HANDLE fileHandle, void** Buffer, std::size_t szBuffer);
	void* PebModuleUtil(__in std::uint32_t hashedModuleName);
    bool FetchFunctionPtrsUtil();
    void CleanupUtil();
    bool FetchSystemPathUtil();
    bool AppendNtSystemFilePathUtil(__in const wchar_t* moduleName, __in void* ntModuleName);
    template<typename input> bool StringConversionUtil(__in void* destination, __in  input source);
    bool ApiStringCompare(__in std::wstring apiModuleName);
	void* FetchFunction(std::uint32_t hashedName);
    bool Init();

public:
    
    ::LibraryLoader(bool* initCheck)
    {
        if (!this->Init())
        {
            *initCheck = false;
            return;
        }

        *initCheck = true;
    }

    void* FunctionAddrUtil(__in void* mappedBase, __in std::uint32_t hashedModuleName, __in std::uint32_t hashedProcName);
    
    void* CustomLoadLibrary(__in const wchar_t* moduleName, __out std::size_t* szImage, __in bool isFilePath, int fileFlag, int loadFlag);
  
    
    ~LibraryLoader()
    {
        this->CleanupUtil();
    }
};


using fnNtOpenFile = NTSTATUS(__fastcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, DWORD, DWORD);

using fnNtReadFile = NTSTATUS (__fastcall*)(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, DWORD, PLARGE_INTEGER, PDWORD);

using fnNtQueryInformationFile = NTSTATUS (__fastcall*)(HANDLE, PIO_STATUS_BLOCK, PVOID, DWORD, FILE_INFORMATION_CLASS);

using fnNtAllocateVirtualMemory = NTSTATUS (__fastcall*)(HANDLE, PVOID*, DWORD64, PSIZE_T, DWORD, DWORD);

using fnNtFreeVirtualMemory = NTSTATUS (__fastcall*)(HANDLE, PVOID, PSIZE_T, DWORD);

using fnRtlAddFunctionTable = BOOLEAN (__fastcall*)(PRUNTIME_FUNCTION, DWORD, DWORD64);

using fnNtCLose = NTSTATUS (__fastcall*)(HANDLE);

using fnLdrLoadDll = NTSTATUS (__fastcall*)(PWSTR, PDWORD, PUNICODE_STRING, PVOID*);

using fnLdrGetProcedureAddress = NTSTATUS (__fastcall*)(HMODULE, PANSI_STRING, WORD, PVOID);

using fnRtlAnsiStringToUnicodeString = NTSTATUS(__fastcall*)(PUNICODE_STRING, PANSI_STRING, BOOLEAN);

using DLLMAIN = BOOLEAN(__stdcall*)(HINSTANCE, DWORD, LPVOID);



enum LibLoaderFlags
{
    MapDataOnly,
    LoadForData,
    LoadWithExecute,
    FileIsDll,
    FileIsExe
};